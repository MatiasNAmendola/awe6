<haxe>
	<class path="awe6.interfaces.IEncrypter" params="" file="src/awe6/interfaces/IEncrypter.hx" interface="1">
		<encrypt public="1" set="method">
			<f a="value:?secret">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>
	 * Encrypts bytes
	 * @param	value	The unencrypted data. 
	 * @param	?secret	The secret key to encrypt the data with.  Leave blank to use default secret key.
	 * @return	Encrypted (or obfuscated) version of the original.
	 </haxe_doc>
		</encrypt>
		<decrypt public="1" set="method">
			<f a="value:?secret">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>
	 * Decrypts bytes.
	 * @param	value	The encrypted data.
	 * @param	?secret	The secret key to encrypt the data with.  Leave blank to use default secret key.
	 * @return	Decrypted (or unobfuscated) version of the encrypted data.
	 </haxe_doc>
		</decrypt>
		<haxe_doc><![CDATA[
 * The IEncrypter interface should be implemented by objects intending to encrypt or decrypt bytes.
 * <p>Due to decompiling client side applications, encryption should not to be considered secure, merely obfuscated / hidden from plainsite.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="C:\Motion-Twin\haxe/std/flash9/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\Motion-Twin\haxe/std/flash9/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.NativeMenuItem" params="" file="C:\Motion-Twin\haxe/std/flash9/display/NativeMenuItem.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<enabled public="1"><e path="Bool"/></enabled>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1"><c path="String"/></CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1"><c path="String"/></DIRECT_CONNECTIONS>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<audioReliable public="1"><e path="Bool"/></audioReliable>
		<audioSampleAccess public="1"><e path="Bool"/></audioSampleAccess>
		<backBufferLength public="1"><c path="Float"/></backBufferLength>
		<backBufferTime public="1"><c path="Float"/></backBufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferTimeMax public="1"><c path="Float"/></bufferTimeMax>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<client public="1"><d/></client>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<dataReliable public="1"><e path="Bool"/></dataReliable>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<farID public="1" set="null"><c path="String"/></farID>
		<farNonce public="1" set="null"><c path="String"/></farNonce>
		<inBufferSeek public="1"><e path="Bool"/></inBufferSeek>
		<info public="1" set="null"><c path="flash.net.NetStreamInfo"/></info>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<maxPauseBufferTime public="1"><c path="Float"/></maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1"><e path="Bool"/></multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1"><c path="Float"/></multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1"><c path="Float"/></multicastFetchPeriod>
		<multicastInfo public="1"><c path="flash.net.NetStreamMulticastInfo"/></multicastInfo>
		<multicastPushNeighborLimit public="1"><c path="Float"/></multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1"><c path="Float"/></multicastRelayMarginDuration>
		<multicastWindowDuration public="1"><c path="Float"/></multicastWindowDuration>
		<nearNonce public="1" set="null"><c path="String"/></nearNonce>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<peerStreams public="1" set="null"><c path="Array"><d/></c></peerStreams>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<time public="1" set="null"><c path="Float"/></time>
		<useHardwareDecoder public="1"><e path="Bool"/></useHardwareDecoder>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<videoReliable public="1"><e path="Bool"/></videoReliable>
		<videoSampleAccess public="1"><e path="Bool"/></videoSampleAccess>
		<videoStreamSettings public="1"><c path="flash.media.VideoStreamSettings"/></videoStreamSettings>
		<appendBytes public="1"><f a="bytes">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></appendBytes>
		<appendBytesAction public="1"><f a="netStreamAppendBytesAction">
	<c path="String"/>
	<e path="Void"/>
</f></appendBytesAction>
		<attach public="1"><f a="connection">
	<c path="flash.net.NetConnection"/>
	<e path="Void"/>
</f></attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<onPeerConnect public="1" set="method"><f a="subscriber">
	<c path="flash.net.NetStream"/>
	<e path="Bool"/>
</f></onPeerConnect>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<play2 public="1" set="method"><f a="param">
	<c path="flash.net.NetStreamPlayOptions"/>
	<e path="Void"/>
</f></play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<step public="1"><f a="frames">
	<c path="Int"/>
	<e path="Void"/>
</f></step>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.system.IMEConversionMode" params="" file="C:\Motion-Twin\haxe/std/flash9/system/IMEConversionMode.hx">
		<UNKNOWN/>
		<KOREAN/>
		<JAPANESE_KATAKANA_HALF/>
		<JAPANESE_KATAKANA_FULL/>
		<JAPANESE_HIRAGANA/>
		<CHINESE/>
		<ALPHANUMERIC_HALF/>
		<ALPHANUMERIC_FULL/>
	</enum>
	<enum path="flash.display.ShaderPrecision" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
	</enum>
	<enum path="flash.utils.Endian" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
	</enum>
	<class path="IntHash" params="T" file="C:\Motion-Twin\haxe/std/flash9/_std/IntHash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenuClipboardItems.hx" extern="1">
		<clear public="1"><e path="Bool"/></clear>
		<copy public="1"><e path="Bool"/></copy>
		<cut public="1"><e path="Bool"/></cut>
		<paste public="1"><e path="Bool"/></paste>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="awe6.interfaces.EScene" params="" file="src/awe6/interfaces/EScene.hx">
		<TEST><haxe_doc>
	 * Recommended to be used as a testing sandbox to test new entities etc.
	 </haxe_doc></TEST>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EScene to be extended (e.g. for using project specific enumerated scene types).
	 </haxe_doc>
		</SUB_TYPE>
		<SETTINGS/>
		<SELECT_SESSION/>
		<REWARDS/>
		<RESULTS/>
		<MENU/>
		<INTRO/>
		<INSTRUCTIONS/>
		<GAME/>
		<haxe_doc><![CDATA[
 * Default Scene types.  A basic game can be made using these defaults.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<class path="flash.display.Graphics" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginShaderFill public="1" set="method"><f a="shader:?matrix">
	<c path="flash.display.Shader"/>
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></beginShaderFill>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<copyFrom public="1" set="method"><f a="sourceGraphics">
	<c path="flash.display.Graphics"/>
	<e path="Void"/>
</f></copyFrom>
		<cubicCurveTo public="1"><f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></cubicCurveTo>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method"><f a="graphicsData">
	<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
	<e path="Void"/>
</f></drawGraphicsData>
		<drawPath public="1" set="method"><f a="commands:data:?winding">
	<c path="flash.Vector"><c path="Int"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="flash.display.GraphicsPathWinding"/>
	<e path="Void"/>
</f></drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method"><f a="vertices:?indices:?uvtData:?culling">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Int"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="flash.display.TriangleCulling"/>
	<e path="Void"/>
</f></drawTriangles>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></lineBitmapStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineShaderStyle public="1" set="method"><f a="shader:?matrix">
	<c path="flash.display.Shader"/>
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></lineShaderStyle>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\Motion-Twin\haxe/std/flash9/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display3D.Context3DProgramType" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
	</enum>
	<class path="awe6.interfaces.ITextStyle" params="" file="src/awe6/interfaces/ITextStyle.hx" interface="1">
		<font public="1">
			<c path="String"/>
			<haxe_doc>
	 * The name of the font, as a string.
	 </haxe_doc>
		</font>
		<size public="1">
			<c path="Float"/>
			<haxe_doc>
	 * The point size of text.
	 </haxe_doc>
		</size>
		<color public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The color of the text.
	 </haxe_doc>
		</color>
		<align public="1">
			<e path="awe6.interfaces.ETextAlign"/>
			<haxe_doc>
	 * Font horizontal alignment.
	 </haxe_doc>
		</align>
		<spacingHorizontal public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Space in pixels added between each character.
	 </haxe_doc>
		</spacingHorizontal>
		<spacingVertical public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Space in pixels added between each new line (often called leading).
	 </haxe_doc>
		</spacingVertical>
		<isBold public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Font weight.
	 </haxe_doc>
		</isBold>
		<isItalic public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Font emphasis.
	 </haxe_doc>
		</isItalic>
		<thickness public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Thickness of the glyph edges of this font.  Range: -1...1.  Default is 0.
	 </haxe_doc>
		</thickness>
		<filters public="1">
			<c path="Array"><d/></c>
			<haxe_doc>
	 * Collection of visual filters appled to font.
	 </haxe_doc>
		</filters>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * String representation of this object.
	 * @return	Representation of this object.
	 </haxe_doc>
		</toString>
		<clone public="1" set="method">
			<f a=""><c path="awe6.interfaces.ITextStyle"/></f>
			<haxe_doc>
	 * Duplicates this TextStyle.
	 * @return	A duplicate.
	 </haxe_doc>
		</clone>
		<haxe_doc>
 * The ITextStyle interface should be implemented by objects created by the createTextStyle method of IFactory.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.TextStyle" params="" file="src/awe6/core/TextStyle.hx">
		<implements path="awe6.interfaces.ITextStyle"/>
		<font public="1"><c path="String"/></font>
		<size public="1"><c path="Float"/></size>
		<color public="1"><c path="Int"/></color>
		<align public="1"><e path="awe6.interfaces.ETextAlign"/></align>
		<spacingHorizontal public="1"><c path="Float"/></spacingHorizontal>
		<spacingVertical public="1"><c path="Float"/></spacingVertical>
		<isBold public="1"><e path="Bool"/></isBold>
		<isItalic public="1"><e path="Bool"/></isItalic>
		<thickness public="1"><c path="Float"/></thickness>
		<filters public="1"><c path="Array"><d/></c></filters>
		<toString public="1" set="method" line="66"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="71"><f a=""><c path="awe6.interfaces.ITextStyle"/></f></clone>
		<new public="1" set="method" line="52"><f a="?p_font:?p_size:?p_color:?p_isBold:?p_isItalic:?p_align:?p_spacingHorizontal:?p_spacingVertical:?p_thickness:?p_filters">
	<c path="String"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="awe6.interfaces.ETextAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The TextStyle class provides a minimalist implementation of the ITextStyle interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IResettable" params="" file="src/awe6/interfaces/IResettable.hx" interface="1">
		<reset public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Call method to return object to it's initial state.
	 * @return	True if reset was successful, false otherwise.
	 </haxe_doc>
		</reset>
		<haxe_doc>
 * The IResettable interface should be implemented by objects intended to be reset (returned to initial state).
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IInputManager" params="" file="src/awe6/interfaces/IInputManager.hx" interface="1">
		<implements path="awe6.interfaces.IResettable"/>
		<joypad public="1" set="null">
			<c path="awe6.interfaces.IInputJoypad"/>
			<haxe_doc>
	 * The default virtual joypad user input: simple 4 directional controller with 2 fire buttons.  Listens to cursor keys and WASD keys.
	 </haxe_doc>
		</joypad>
		<keyboard public="1" set="null">
			<c path="awe6.interfaces.IInputKeyboard"/>
			<haxe_doc>
	 * The virtual keyboard user input: every key on the keyboard.
	 </haxe_doc>
		</keyboard>
		<mouse public="1" set="null">
			<c path="awe6.interfaces.IInputMouse"/>
			<haxe_doc>
	 * The virtual mouse user input: 3 button mouse and scroll wheel.
	 </haxe_doc>
		</mouse>
		<createJoypad public="1" set="method">
			<f a="?up:?right:?down:?left:?primary:?secondary:?upAlt:?rightAlt:?downAlt:?leftAlt:?primaryAlt:?secondaryAlt">
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<c path="awe6.interfaces.IInputJoypad"/>
			</f>
			<haxe_doc>
	 * Factory method to create a virtual joypad with custom key controls.
	 * @param	?up	The key for up directional movement.  Defaults to up cursor.
	 * @param	?right	The key for right directional movement.  Defaults to right cursor.
	 * @param	?down	The key for down directional movement.  Defaults to down cursor.
	 * @param	?left	The key for left directional movement.  Defaults to left cursor.
	 * @param	?primary	The key for primary fire.  Defaults to space.
	 * @param	?secondary	The key for secondary fire.  Defaults to Z key.
	 * @param	?upAlt	Optional alternative key for up directional movement.
	 * @param	?rightAlt	Optional alternative key for right directional movement.
	 * @param	?downAlt	Optional alternative key for down directional movement.
	 * @param	?leftAlt	Optional alternative key for left directional movement.
	 * @param	?primaryAlt	Optional alternative key for primary fire.
	 * @param	?secondaryAlt	Optional alternative key for secondary fire.
	 * @return	A virtual joypad with custom key controls.
	 </haxe_doc>
		</createJoypad>
		<haxe_doc><![CDATA[
 * The IInputManager interface should be implemented by an object wishing to provide user input states to the kernel.
 * <p>The state machine represents the configuration of the input devices at any specific update frame.</p>
 * <p>State based input is useful for many types of game mechanics, including: momentum, instant replays and special move combos.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.ISession" params="" file="src/awe6/interfaces/ISession.hx" interface="1">
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The unique identifier of this session.
	 </haxe_doc>
		</id>
		<isTester public="1" get="_get_isTester" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Useful for testing and debug.
	 </haxe_doc>
		</isTester>
		<clone public="1" set="method">
			<f a="newId">
				<c path="String"/>
				<c path="awe6.interfaces.ISession"/>
			</f>
			<haxe_doc>
	 * Creates a copy of the current session.
	 * @param	newId	The unique identifier of the copy.
	 * @return	A copy of the current session.
	 </haxe_doc>
		</clone>
		<reset public="1" set="method">
			<f a="?isSaved">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Reverts the session back to factory settings (as if created afresh).
	 * @param	?isSaved	If true immediately writes the reset session to disk.
	 </haxe_doc>
		</reset>
		<save public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Writes the session to disk.
	 </haxe_doc>
		</save>
		<delete public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes the session from disk.
	 </haxe_doc>
		</delete>
		<getPercentageComplete public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Helper function to calculate overall progress of a game / rewards acquired etc. 
	 * @return	Range 0...1: with 1 representing complete.
	 </haxe_doc>
		</getPercentageComplete>
		<getSessionIds public="1" set="method">
			<f a="?suggestions">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
	 * Retrieve the collection of sessions identifiers currently saved to disk.
	 * @param	?suggestions	Prepopulates results with the suggestions.
	 * @return	A collection of sessions identifiers currently save to disk.
	 </haxe_doc>
		</getSessionIds>
		<getSessions public="1" set="method">
			<f a="?suggestions">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="awe6.interfaces.ISession"/></c>
			</f>
			<haxe_doc>
	 * Retrieve the collection of sessions currently saved to disk.
	 * @param	?suggestions	Prepopulates results with the suggestions.
	 * @return	A collection of sessions currently save to disk.
	 </haxe_doc>
		</getSessions>
		<deleteAllSessions public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes all session data from disk.
	 </haxe_doc>
		</deleteAllSessions>
		<haxe_doc><![CDATA[
 * The ISession interface should be implemented by objects wishing to preserve interactive information interchange.
 * <p>The session can be used as both memento and arbitrator between subsystems - including entities and scenes.</p>
 * <p>Sessions can be permanently stored and retrieved on future application ezecution.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.ASession" params="" file="src/awe6/core/drivers/ASession.hx">
		<implements path="awe6.interfaces.ISession"/>
		<DEBUG_ID public="1" get="inline" set="null" line="43" static="1"><c path="String"/></DEBUG_ID>
		<_VERSION_ID get="inline" set="null" line="44" static="1"><c path="String"/></_VERSION_ID>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_tools><c path="awe6.interfaces.ITools"/></_tools>
		<_data><d/></_data>
		<_savedData><d/></_savedData>
		<_version><c path="Int"/></_version>
		<id public="1" set="null"><c path="String"/></id>
		<isTester public="1" get="_get_isTester" set="null"><e path="Bool"/></isTester>
		<loadCount public="1"><c path="Int"/></loadCount>
		<saveCount public="1"><c path="Int"/></saveCount>
		<_init set="method" line="71"><f a=""><e path="Void"/></f></_init>
		<_driverLoad set="method" line="89"><f a=""><e path="Void"/></f></_driverLoad>
		<_driverSave set="method" line="95"><f a=""><e path="Void"/></f></_driverSave>
		<_driverReset set="method" line="101"><f a=""><e path="Void"/></f></_driverReset>
		<_getter set="method" line="107"><f a=""><e path="Void"/></f></_getter>
		<_setter set="method" line="115"><f a=""><e path="Void"/></f></_setter>
		<_resetter set="method" line="123"><f a=""><e path="Void"/></f></_resetter>
		<clone public="1" get="inline" set="null" line="131"><f a="p_newId">
	<c path="String"/>
	<c path="awe6.interfaces.ISession"/>
</f></clone>
		<reset public="1" get="inline" set="null" line="138"><f a="?p_isSaved">
	<e path="Bool"/>
	<e path="Void"/>
</f></reset>
		<delete public="1" get="inline" set="null" line="149"><f a=""><e path="Void"/></f></delete>
		<save public="1" get="inline" set="null" line="154"><f a=""><e path="Void"/></f></save>
		<getPercentageComplete public="1" set="method" line="163"><f a=""><c path="Float"/></f></getPercentageComplete>
		<getSessionIds public="1" set="method" line="169"><f a="?p_suggestions">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></getSessionIds>
		<getSessions public="1" set="method" line="190"><f a="?p_suggestions">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="awe6.interfaces.ISession"/></c>
</f></getSessions>
		<deleteAllSessions public="1" set="method" line="201"><f a=""><e path="Void"/></f></deleteAllSessions>
		<toString public="1" set="method" line="206"><f a=""><c path="String"/></f></toString>
		<_get_isTester set="method" line="211"><f a=""><e path="Bool"/></f></_get_isTester>
		<new public="1" set="method" line="58"><f a="p_kernel:?p_id">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The ASession class provides a minimalist abstract implementation of the ISession interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<typedef path="awe6.core.Context" params="" file="src/awe6/core/Context.hx">
		<c path="flash.display.Sprite"/>
		<haxe_doc><![CDATA[
 * The Context class is a target specific class that defines a native element - typically a view.
 * It is intended to be the only publicly exposed target specific parameter / member.
 * <p>Context includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="haxe.FastList_awe6_core__MessageManager__HelperSubscription" params="" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell_awe6_core__MessageManager__HelperSubscription"/></head>
		<add public="1" get="inline" set="null" line="60">
			<f a="item">
				<c path="awe6.core._MessageManager._HelperSubscription">
					<d/>
					<d/>
				</c>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" get="inline" set="null" line="68">
			<f a=""><t path="Null"><c path="awe6.core._MessageManager._HelperSubscription">
	<d/>
	<d/>
</c></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="awe6.core._MessageManager._HelperSubscription">
	<d/>
	<d/>
</c></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" get="inline" set="null" line="90">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" set="method" line="98">
			<f a="v">
				<c path="awe6.core._MessageManager._HelperSubscription">
					<d/>
					<d/>
				</c>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="123">
			<f a=""><t path="Iterator"><c path="awe6.core._MessageManager._HelperSubscription">
	<d/>
	<d/>
</c></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="141">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="54">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
	</class>
	<class path="awe6.interfaces.IPauseable" params="" file="src/awe6/interfaces/IPauseable.hx" interface="1">
		<isActive public="1" set="_set_isActive">
			<e path="Bool"/>
			<haxe_doc>
	 * Determines if the object is updating or not.
	 </haxe_doc>
		</isActive>
		<pause public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Sets isActive to false.
	 </haxe_doc>
		</pause>
		<resume public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Sets isActive to true.
	 </haxe_doc>
		</resume>
		<haxe_doc>
 * The IPauseable interface should be implemented by objects intended to be temporarily disabled from the broad phase update traversal.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IDisposable" params="" file="src/awe6/interfaces/IDisposable.hx" interface="1">
		<isDisposed public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Returns true if the object has been disposed (or is being disposed).
	 </haxe_doc>
		</isDisposed>
		<dispose public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Disposes this object by deallocating all used resources and breaking all
	 * (non-weak) references to other objects. This method must be the final
	 * call in the object's life cycle. No methods except this method should be
	 * called on the object and no properties of the object should be read or
	 * written after a call to this object; otherwise the behaviour is
	 * unreliable. The object may call the method on itself, directly or
	 * indirectly.
	 </haxe_doc>
		</dispose>
		<haxe_doc><![CDATA[
 * The IDisposable interface should be implemented by objects that require
 * specialised garbage collection or memory deallocation.
 * <p>Once an object is disposed it should be automatically removed from parent heirachies.</p>
 * @author Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IUpdateable" params="" file="src/awe6/interfaces/IUpdateable.hx" interface="1">
		<getAge public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * The age of the object.
	 * @param	?asTime	If true treats the time as milliseconds, otherwise as frame updates.
	 * @return	The age of the object (as elapsed time, not time since birth).
	 </haxe_doc>
		</getAge>
		<update public="1" set="method">
			<f a="?deltaTime">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Used to modify the internal state according to object specific logic and the elapsed time.
	 * <p>This method is called internally by the framework, it will rarely need to be called directly.</p>
	 * @param	?deltaTime	The time elapsed between this update and the previous update.  Can be used to accurately influence rate of change - e.g. speed.
	 ]]></haxe_doc>
		</update>
		<haxe_doc>
 * The IUpdatable interface should be implemented by any object wishing to enter the broad phase update traversal stack.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IProcess" params="" file="src/awe6/interfaces/IProcess.hx" interface="1">
		<implements path="awe6.interfaces.IPauseable"/>
		<implements path="awe6.interfaces.IDisposable"/>
		<implements path="awe6.interfaces.IUpdateable"/>
		<haxe_doc><![CDATA[
 * The IProcess represents the smallest atom of the awe6 framework.
 * <p>Many managers will implement this interface.</p>
 * @author	Robet Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.Process" params="" file="src/awe6/core/Process.hx">
		<implements path="awe6.interfaces.IProcess"/>
		<isActive public="1" set="_set_isActive"><e path="Bool"/></isActive>
		<isDisposed public="1" set="null"><e path="Bool"/></isDisposed>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_tools><c path="awe6.core.Tools"/></_tools>
		<_age><c path="Int"/></_age>
		<_updates><c path="Int"/></_updates>
		<_isEntity><e path="Bool"/></_isEntity>
		<_isSetterBypassed><e path="Bool"/></_isSetterBypassed>
		<_init set="method" line="65"><f a=""><e path="Void"/></f></_init>
		<dispose public="1" get="inline" set="null" line="75"><f a=""><e path="Void"/></f></dispose>
		<_disposer set="method" line="94"><f a=""><e path="Void"/></f></_disposer>
		<getAge public="1" set="method" line="99"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Int"/>
</f></getAge>
		<update public="1" get="inline" set="null" line="104"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></update>
		<_updater set="method" line="119"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_set_isActive set="method" line="124"><f a="p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isActive>
		<pause public="1" get="inline" set="null" line="146"><f a=""><e path="Void"/></f></pause>
		<_pauser set="method" line="165"><f a=""><e path="Void"/></f></_pauser>
		<resume public="1" get="inline" set="null" line="170"><f a=""><e path="Void"/></f></resume>
		<_resumer set="method" line="190"><f a=""><e path="Void"/></f></_resumer>
		<new public="1" set="method" line="57"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The Process class provides a minimalist implementation of the IProcess interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IAgendaManager" params="" file="src/awe6/interfaces/IAgendaManager.hx" interface="1">
		<agenda public="1" get="_get_agenda" set="null">
			<e path="awe6.interfaces.EAgenda"/>
			<haxe_doc>
	 * The object's current agenda.
	 </haxe_doc>
		</agenda>
		<setAgenda public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EAgenda"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Change the object's current agenda.
	 * @param	type	The new agenda.  If none is specified will assign to EAgenda.ALWAYS.
	 * @return	Returns true if the agenda has changed, false otherwise.
	 </haxe_doc>
		</setAgenda>
		<haxe_doc>
 * Objects intending to provide an Agenda driven state machine should implement this interface.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IEntityCollection" params="" file="src/awe6/interfaces/IEntityCollection.hx" interface="1">
		<addEntity public="1" set="method">
			<f a="entity:?agenda:?isAddedToView:?viewPriority">
				<c path="awe6.interfaces.IEntity"/>
				<e path="awe6.interfaces.EAgenda"/>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adds an entity to this object's children.
	 * @param	entity	The entity to add.
	 * @param	?agenda	Assigns the entity to a specific agenda.  If none is specified will assign to EAgenda.ALWAYS.
	 * @param	?isAddedToView	If true will add the child entity's view to this object's view.
	 * @param	?viewPriority	Sets the child entity's view stack priority order (higher numbers appear closer to the top of the stack).
	 </haxe_doc>
		</addEntity>
		<removeEntity public="1" set="method">
			<f a="entity:?agenda:?isRemovedFromView">
				<c path="awe6.interfaces.IEntity"/>
				<e path="awe6.interfaces.EAgenda"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes an entity from this object's children.
	 * @param	entity	The entity to remove.
	 * @param	?agenda	If set then will only remove the specified entity from this agenda, else will remove from all agendas.
	 * @param	?isRemovedFromView	If true the child entity's view will be removed from this object's view.
	 </haxe_doc>
		</removeEntity>
		<getEntities public="1" set="method">
			<f a="?agenda">
				<e path="awe6.interfaces.EAgenda"/>
				<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
			</f>
			<haxe_doc><![CDATA[
	 * Retrieves all child entities.
	 * <p>Consider this a runtime only method, rather than calling it during constructor or initialization phases.</p>
	 * @param	?agenda	Used to filter results to the specified agenda.
	 * @return	Array of matching entities.
	 ]]></haxe_doc>
		</getEntities>
		<getEntitiesByClass public="1" params="T" set="method">
			<f a="classType:?agenda:?isBubbleDown:?isBubbleUp:?isBubbleEverywhere">
				<c path="Class"><c path="getEntitiesByClass.T"/></c>
				<e path="awe6.interfaces.EAgenda"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Array"><c path="getEntitiesByClass.T"/></c>
			</f>
			<haxe_doc><![CDATA[
	 * Retrieves all child entities that match type.
	 * <p>Consider this a runtime only method, rather than calling it during constructor or initialization phases.</p>
	 * @param	classType	The type of class to match (can be any class, type or interface).
	 * @param	agenda	Used to filter results to the specified agenda.
	 * @param	?isBubbleDown	Set to true if you want to search this object's children for the requested entity.
	 * @param	?isBubbleUp	Set to true if you want to search this object's parent for the requested entity.
	 * @param	?isBubbleEverywhere	Set to true if you want to search the entire entity traversal stack for the requested entity.
	 * @return	Array of matching entities.
	 ]]></haxe_doc>
		</getEntitiesByClass>
		<getEntityById public="1" set="method">
			<f a="id:?agenda:?isBubbleDown:?isBubbleUp:?isBubbleEverywhere">
				<c path="String"/>
				<e path="awe6.interfaces.EAgenda"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="awe6.interfaces.IEntity"/>
			</f>
			<haxe_doc><![CDATA[
	 * Retrieves the child entity with the specified id. 
	 * <p>Consider this a runtime only method, rather than calling it during constructor or initialization phases.</p>
	 * @param	id	The unique identifier of the entity you want to retrieve.
	 * @param	?agenda	Used to filter results to the specified agenda.
	 * @param	?isBubbleDown	Set to true if you want to search this object's children for the requested entity.
	 * @param	?isBubbleUp	Set to true if you want to search this object's parent for the requested entity.
	 * @param	?isBubbleEverywhere	Set to true if you want to search the entire entity traversal stack for the requested entity.
	 * @return	The requested entity or null if no entity with this id was found.
	 ]]></haxe_doc>
		</getEntityById>
		<haxe_doc>
 * The IEntityCollection interface should be implemented by objects which compose multiple entities.
 * @author Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IViewable" params="" file="src/awe6/interfaces/IViewable.hx" interface="1">
		<view public="1" get="_get_view" set="null">
			<c path="awe6.interfaces.IView"/>
			<haxe_doc>
	 * The view bound to this object.
	 </haxe_doc>
		</view>
		<haxe_doc>
 * The IVewable interface should be implemented by all objects that compose a view.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IEntity" params="" file="src/awe6/interfaces/IEntity.hx" interface="1">
		<implements path="awe6.interfaces.IAgendaManager"/>
		<implements path="awe6.interfaces.IEntityCollection"/>
		<implements path="awe6.interfaces.IViewable"/>
		<implements path="awe6.interfaces.IProcess"/>
		<id public="1" set="_set_id">
			<c path="String"/>
			<haxe_doc><![CDATA[
	 * The unique identifier of this entity.
	 * <p>This value is very useful for retrieving a specific entity.</p> 
	 ]]></haxe_doc>
		</id>
		<parent public="1" get="_get_parent" set="null">
			<c path="awe6.interfaces.IEntityCollection"/>
			<haxe_doc><![CDATA[
	 * The parent of this entity
	 * <p>The reference is null if this entity has no parent (for example an entity not in the entity traversal stack).</p>
	 * <p>Consider this a runtime only property, rather than calling it during constructor or initialization phases.</p>
	 ]]></haxe_doc>
		</parent>
		<remove public="1" set="method">
			<f a="?isRemovedFromView">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Used to easily remove this entity from its parent.
	 * @param	?isRemovedFromView	Determines whether this object's view is removed from the view stack at the same time.
	 </haxe_doc>
		</remove>
		<haxe_doc><![CDATA[
 * The IEntity interface should be implemented by all objects in the entity broad phase traversal stack.
 * <p>The IEntity represents the fundamental awe6 building block and provides sufficient functionality to build most game elements.</p>
 * <p>Project specific entities can be created as custom classes, or by injecting functionality through the IEntity interface.</p>
 * @author Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.Entity" params="" file="src/awe6/core/Entity.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IEntity"/>
		<id public="1" set="_set_id"><c path="String"/></id>
		<agenda public="1" get="_get_agenda" set="null"><e path="awe6.interfaces.EAgenda"/></agenda>
		<parent public="1" get="_get_parent" set="null"><c path="awe6.interfaces.IEntityCollection"/></parent>
		<view public="1" get="_get_view" set="null"><c path="awe6.interfaces.IView"/></view>
		<_entityAgendaPairs><c path="haxe.FastList_awe6_core__Entity__HelperEntityAgendaPair"/></_entityAgendaPairs>
		<_isAgendaDirty><e path="Bool"/></_isAgendaDirty>
		<_cachedEntities><c path="Array"><c path="awe6.interfaces.IEntity"/></c></_cachedEntities>
		<_init set="method" line="61" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="70" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="88" override="1"><f a=""><e path="Void"/></f></_disposer>
		<addEntity public="1" set="method" line="107"><f a="p_entity:?p_agenda:?p_isAddedToView:?p_viewPriority">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addEntity>
		<removeEntity public="1" set="method" line="150"><f a="p_entity:?p_agenda:?p_isRemovedFromView">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEntity>
		<remove public="1" set="method" line="177"><f a="?p_isRemovedFromView">
	<e path="Bool"/>
	<e path="Void"/>
</f></remove>
		<getEntities public="1" set="method" line="185"><f a="?p_agenda">
	<e path="awe6.interfaces.EAgenda"/>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></getEntities>
		<_getEntities set="method" line="190"><f a="?p_agenda">
	<e path="awe6.interfaces.EAgenda"/>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></_getEntities>
		<getEntitiesByClass public="1" params="T" set="method" line="204"><f a="p_classType:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="Class"><c path="getEntitiesByClass.T"/></c>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Array"><c path="getEntitiesByClass.T"/></c>
</f></getEntitiesByClass>
		<getEntityById public="1" set="method" line="230"><f a="p_id:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="String"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="awe6.interfaces.IEntity"/>
</f></getEntityById>
		<setAgenda public="1" set="method" line="264"><f a="p_type">
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
</f></setAgenda>
		<_setParent set="method" line="295"><f a="p_parent">
	<c path="awe6.interfaces.IEntityCollection"/>
	<e path="Void"/>
</f></_setParent>
		<_set_id set="method" line="300"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></_set_id>
		<_get_agenda set="method" line="306"><f a=""><e path="awe6.interfaces.EAgenda"/></f></_get_agenda>
		<_get_parent set="method" line="311"><f a=""><c path="awe6.interfaces.IEntityCollection"/></f></_get_parent>
		<_get_view set="method" line="316"><f a=""><c path="awe6.interfaces.IView"/></f></_get_view>
		<new public="1" set="method" line="54"><f a="p_kernel:?p_id:?p_context">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<t path="awe6.core.Context"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The Entity class provides a minimalist implementation of the IEntity interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AProfiler" params="" file="src/awe6/core/drivers/AProfiler.hx">
		<extends path="awe6.core.Entity"/>
		<_marginHeight><c path="Int"/></_marginHeight>
		<_marginColor><c path="Int"/></_marginColor>
		<_backgroundColor><c path="Int"/></_backgroundColor>
		<_fpsColor><c path="Int"/></_fpsColor>
		<_memoryColor><c path="Int"/></_memoryColor>
		<_fpsLabel><c path="String"/></_fpsLabel>
		<_memoryLabel><c path="String"/></_memoryLabel>
		<_context><t path="awe6.core.Context"/></_context>
		<_agePrev><c path="Int"/></_agePrev>
		<_width><c path="Int"/></_width>
		<_height><c path="Int"/></_height>
		<_init set="method" line="61" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="76" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_driverUpdate set="method" line="87"><f a=""><e path="Void"/></f></_driverUpdate>
		<new public="1" set="method" line="55"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The AProfiler class provides debug information.  Based on net.hires.utils.Stats by Mr.doob & Theo v1.3.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.flash.Profiler" params="" file="src/awe6/core/drivers/flash/Profiler.hx">
		<extends path="awe6.core.drivers.AProfiler"/>
		<_bitmapData><c path="flash.display.BitmapData"/></_bitmapData>
		<_textFormat><c path="flash.text.TextFormat"/></_textFormat>
		<_fpsTextField><c path="flash.text.TextField"/></_fpsTextField>
		<_memoryTextField><c path="flash.text.TextField"/></_memoryTextField>
		<_init set="method" line="54" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverUpdate set="method" line="86" override="1"><f a=""><e path="Void"/></f></_driverUpdate>
		<new public="1" set="method" line="47"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * This Profiler class provides flash target overrides.
 * <p>Based on net.hires.utils.Stats by Mr.doob & Theo v1.3</p>
 * @author	Werner Avenant
 * @author	Mr.doob
 * @author	Theo
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<typedef path="awe6.core.AudioManager" params="" file="src/awe6/core/AudioManager.hx">
		<c path="awe6.core.drivers.flash.AudioManager"/>
		<haxe_doc><![CDATA[
 * The AudioManager class provides a minimalist implementation of the IAudioManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>AudioManager includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<enum path="awe6.interfaces.EMessage" params="" file="src/awe6/interfaces/EMessage.hx">
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EMessage to be extended (e.g. for using project specific mesages).
	 </haxe_doc>
		</SUB_TYPE>
		<RESUME/>
		<PAUSE/>
		<DISPOSE/>
		<haxe_doc>
 * These messages are dispatched internally.
 * @author	Robert Fell
 </haxe_doc>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="C:\Motion-Twin\haxe/std/flash9/media/MicrophoneEnhancedOptions.hx" extern="1">
		<autoGain public="1"><e path="Bool"/></autoGain>
		<echoPath public="1"><c path="Int"/></echoPath>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuItem" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenuItem.hx" extern="1">
		<extends path="flash.display.NativeMenuItem"/>
		<caption public="1"><c path="String"/></caption>
		<separatorBefore public="1"><e path="Bool"/></separatorBefore>
		<visible public="1"><e path="Bool"/></visible>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuItem"/></f></clone>
		<new public="1" set="method"><f a="caption:?separatorBefore:?enabled:?visible">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.interfaces.IMessageManager" params="" file="src/awe6/interfaces/IMessageManager.hx" interface="1">
		<addSubscriber public="1" params="M:T" set="method">
			<f a="subscriber:message:handler:?sender:?senderClassType:?isRemovedAfterFirstSend">
				<c path="awe6.interfaces.IEntity"/>
				<c path="addSubscriber.M"/>
				<f a=":">
					<c path="addSubscriber.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<e path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<c path="Class"><c path="addSubscriber.T"/></c>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Register an entity's interest in a subject.
	 * @param	subscriber	Entity listening / observing for messages.
	 * @param	message	Specific message to listen for.
	 * @param	handler	Function to pass observed messages to: receives Message & Sender and returns true if send propogation is to continue (true should be default behavior).
	 * @param	?sender	Only listen to messages from this entity.
	 * @param	?senderClassType	Only listen to messages from this type of entity.
	 * @param	?isRemovedAfterFirstSend	Once a message has been received, no longer listen for further messages under the same criteria.
	 * @type	<M>	Messages can be any type.  For recursive types use Enums.
	 * @type	<T>	Senders' type.
	 ]]></haxe_doc>
		</addSubscriber>
		<getSubscribers public="1" params="M:T" set="method">
			<f a="?subscriber:?message:?handler:?sender:?senderClassType">
				<c path="awe6.interfaces.IEntity"/>
				<c path="getSubscribers.M"/>
				<f a=":">
					<c path="getSubscribers.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<e path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<c path="Class"><c path="getSubscribers.T"/></c>
				<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
			</f>
			<haxe_doc><![CDATA[
	 * Retrieve all entity's interested in a subject.
	 * <p>All parameters are optional to allow wildcard filtering.</p>
	 * @param	?subscriber	Entity listening / observing for messages.
	 * @param	?message	Specific message to listen for.
	 * @param	?handler	Function to pass observed messages to.
	 * @param	?sender	Only listen to messages from this entity.
	 * @param	?senderClassType	Only listen to messages from this type of entity.
	 * @return	An array of entities corresponding to the specified filters.
	 * @type	<M>	Messages can be any type.  For recursive types use Enums.
	 * @type	<T>	Senders' type.
	 ]]></haxe_doc>
		</getSubscribers>
		<removeSubscribers public="1" params="M:T" set="method">
			<f a="?subscriber:?message:?handler:?sender:?senderClassType">
				<c path="awe6.interfaces.IEntity"/>
				<c path="removeSubscribers.M"/>
				<f a=":">
					<c path="removeSubscribers.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<e path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<c path="Class"><c path="removeSubscribers.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Unsubscribes entities matching the specified criteria.
	 * @param	?subscriber	Entity listening / observing for messages.
	 * @param	?message	Specific message to listen for.
	 * @param	?handler	Function to pass observed messages to.
	 * @param	?sender	Only listen to messages from this entity.
	 * @param	?senderClassType	Only listen to messages from this type of entity.
	 * @type	<M>	Messages can be any type.  For recursive types use Enums.
	 * @type	<T>	Senders' type.
	 ]]></haxe_doc>
		</removeSubscribers>
		<sendMessage public="1" params="M" set="method">
			<f a="message:sender:?isBubbleDown:?isBubbleUp:?isBubbleEverywhere">
				<c path="sendMessage.M"/>
				<c path="awe6.interfaces.IEntity"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Dispatch a message from a specific entity.
	 * @param	message	Message to dispatch.
	 * @param	sender	The originator of the message (can be spoofed).
	 * @param	?isBubbleDown	Set to true if you want to dispatch this message to the sender's children.
	 * @param	?isBubbleUp	Set to true if you want to dispatch this message to the sender's parent.
	 * @param	?isBubbleEverywhere	Set to true if you want to dispatch this message to the entity traversal stack.
	 * @type	<M>	Messages can be any type.  For recursive types use Enums.
	 ]]></haxe_doc>
		</sendMessage>
		<haxe_doc><![CDATA[
 * The IMessageManager should be implemented by objects intending to fulfill Entity to Entity synchronous messaging (also known as events or signals).
 * <p>The interface provides an observer pattern oriented manager allowing any Entity to listen to anything on any other Entity.</p>
 * <p>Note, the author is not a fan of observer pattern and provides this manager with a note of caution - there is <i>always</i> a better way to communicate than to fire shots into the dark!</p>
 * <p>This manager is intentionally abstract / generic.  It allows expressive synchronous events - i.e. use anything as a message (string, enumerator, type, state based object etc).</p>
 * <p>It may make more sense to handle events using an alternative, event or signal specific library.  Adapt one as an IEntity and inject into any scene as needed.</p>
 ]]></haxe_doc>
	</class>
	<class path="flash.errors.Error" params="" file="C:\Motion-Twin\haxe/std/flash9/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\Motion-Twin\haxe/std/flash9/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
	</enum>
	<class path="flash.ui.Mouse" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/Mouse.hx" extern="1">
		<cursor public="1" static="1"><d/></cursor>
		<supportsCursor public="1" static="1"><e path="Bool"/></supportsCursor>
		<supportsNativeCursor public="1" static="1"><e path="Bool"/></supportsNativeCursor>
		<hide public="1" set="method" static="1"><f a=""><e path="Void"/></f></hide>
		<registerCursor public="1" static="1"><f a="name:cursor">
	<c path="String"/>
	<c path="flash.ui.MouseCursorData"/>
	<e path="Void"/>
</f></registerCursor>
		<show public="1" set="method" static="1"><f a=""><e path="Void"/></f></show>
		<unregisterCursor public="1" static="1"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></unregisterCursor>
	</class>
	<typedef path="awe6.core.ASession" params="" file="src/awe6/core/ASession.hx">
		<c path="awe6.core.drivers.flash.Session"/>
		<haxe_doc><![CDATA[
 * The ASession class provides a minimalist abstract implementation of the ISession interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>ASession includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="flash.text.StyleSheet" params="" file="C:\Motion-Twin\haxe/std/flash9/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="awe6.interfaces.ITools" params="" file="src/awe6/interfaces/ITools.hx" interface="1">
		<implements path="awe6.interfaces.IEncrypter"/>
		<BIG_NUMBER public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Used as an arbitrarily high number to avoid infinity and division by zero issues.
	 </haxe_doc>
		</BIG_NUMBER>
		<createGuid public="1" set="method">
			<f a="?isSmall:?prefix">
				<e path="Bool"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Creates a Globally Unique Identifier.
	 * @param	?isSmall	If true returns an 8 bit identifier, 16 bit otherwise.
	 * @param	?prefix	Adds characters to the front of the GUID.
	 * @return	A Globally Unique Identifier.
	 </haxe_doc>
		</createGuid>
		<ease public="1" set="method">
			<f a="originalValue:newValue:ease">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Find the tween of two values.
	 * @param	originalValue	Value A.
	 * @param	newValue	Value B.
	 * @param	ease	The proportion of A:B.
	 * @return	The proportional value of A:B.
	 </haxe_doc>
		</ease>
		<sortByString public="1" set="method">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Sorting function for String collections.
	 * @param	a	Value A.
	 * @param	b	Value B.
	 * @return	-1 if A<B, 1 if A>B or 0 if A==B.
	 ]]></haxe_doc>
		</sortByString>
		<sortByInt public="1" set="method">
			<f a="a:b">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Sorting function for Int collections.
	 * @param	a	Value A.
	 * @param	b	Value B.
	 * @return	-1 if A<B, 1 if A>B or 0 if A==B.
	 ]]></haxe_doc>
		</sortByInt>
		<sortByPriority public="1" set="method">
			<f a="a:b">
				<c path="awe6.interfaces.IPriority"/>
				<c path="awe6.interfaces.IPriority"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Sorting function for IPriority collections.
	 * @param	a	Value A.
	 * @param	b	Value B.
	 * @return	-1 if A<B, 1 if A>B or 0 if A==B.
	 ]]></haxe_doc>
		</sortByPriority>
		<toUpperCaseFirst public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Creates a copy of a string with the first character uppercased. 
	 * @param	value	The string to transform.
	 * @return	Copy of a string with the first character uppercased.
	 </haxe_doc>
		</toUpperCaseFirst>
		<toCamelCase public="1" set="method">
			<f a="value:?isUpper">
				<c path="String"/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	 * Turns a word or sentence into camelCase.
	 * <p>E.g. "this example string" becomes "thisExampleString".</p>
	 * @param	value	The string to transform.
	 * @param	?isUpper	If true returns PascalCase (first character uppercased).
	 * @return	camelCase or PascalCase representation of a string.
	 ]]></haxe_doc>
		</toCamelCase>
		<toConstCase public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	 * Turns a word of sentence into CONST_CASE.
	 * <p>E.g. "this example string" becomes "THIS_EXAMPLE_STRING".</p>
	 * @param	value	The string to transform.
	 * @return	CONST_CASE representation of a string.
	 ]]></haxe_doc>
		</toConstCase>
		<fromCamelCase public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	 * Reverts a camelCase string to a word or phrase.
	 * <p>E.g. "thisExampleString" becomes "this example string".</p>
	 * @param	value	The camelCase string to revert.
	 * @return	Word or phrase.
	 ]]></haxe_doc>
		</fromCamelCase>
		<fromConstCase public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	 * Reverts a CONST_CASE string to a word or phrase.
	 * <p>E.g. "THIS_EXAMPLE_STRING" becomes "this example string"</p>
	 * @param	value	The CONST_CASE string to revert.
	 * @return	Word or phrase.
	 ]]></haxe_doc>
		</fromConstCase>
		<toWords public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Reverts either a camelCase or CONST_CASE string to a word or phrase.
	 * @param	value	ThecamelCase or CONST_CASE string.
	 * @return	Word or phrase.
	 </haxe_doc>
		</toWords>
		<limit public="1" set="method">
			<f a="value:min:max">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc><![CDATA[
	 * Clamps a value between a floor and ceiling boundary.
	 * @param	value	The value to clamp.
	 * @param	min	The floor.
	 * @param	max	The ceiling.
	 * @return	Value >= floor and <= ceiling.
	 ]]></haxe_doc>
		</limit>
		<range public="1" set="method">
			<f a="value:min:max">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Wraps a value between a floor and ceiling boundary.
	 * @param	value	The value to wrap.
	 * @param	min	The floor.
	 * @param	max	The ceiling.
	 * @return	A value between floor and ceiling proportional to over or under shoot.
	 </haxe_doc>
		</range>
		<swap public="1" params="T" set="method">
			<f a="a:b">
				<c path="swap.T"/>
				<c path="swap.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Replaces two objects with the content of the other.
	 </haxe_doc>
		</swap>
		<isOdd public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Not divisible by two.
	 * @param	value	The value to check.
	 * @return	True if value not divisible by two.
	 </haxe_doc>
		</isOdd>
		<isEven public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Divisible by two.
	 * @param	value	The value to check.
	 * @return	True if value divisible by two.
	 </haxe_doc>
		</isEven>
		<sgn public="1" set="method">
			<f a="value">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine whether a value is less than zero, equal to zero or greater than zero.
	 * @param	value	The value to check.
	 * @return	-1 if <0, 1 if >0, 0 otherwise.
	 ]]></haxe_doc>
		</sgn>
		<isBool public="1" set="method">
			<f a="value">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine whether a value is true.
	 * <p>Results vary based on the context of checked value.  Usually safer to do your own Bool checks.</p>
	 * @param	value	The value to check.
	 * @return	True if the value is true.
	 ]]></haxe_doc>
		</isBool>
		<nearestSquare public="1" set="method">
			<f a="value">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[
	 * Calculate the nearest square number to a given value.
	 * <p>Useful for performance routines.</p>
	 * @param	value	The value to check.
	 * @return	A square number nearest to the value.
	 ]]></haxe_doc>
		</nearestSquare>
		<convertUpdatesToFormattedTime public="1" set="method">
			<f a="updates:?delimiter">
				<c path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a string representing a clock in the format "hh'mm'ss".
	 * <p>Uses IFactory.targetFramerate to determine the duration from updates.</p>
	 * @param	updates	The update cycles elapsed in the duration.
	 * @param	?delimiter	The character used to separate the components (default: "'").
	 * @return	String representing a clock in the format "hh:mm:ss".
	 ]]></haxe_doc>
		</convertUpdatesToFormattedTime>
		<convertAgeToFormattedTime public="1" set="method">
			<f a="age:?delimiter">
				<c path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Creates a string representing a clock in the format "hh'mm'ss".
	 * @param	age	The time elapsed in the duration as milliseconds.
	 * @param	?delimiter	The character used to separate the components (default: "'").
	 * @return	String representing a clock in the format "hh:mm:ss".
	 </haxe_doc>
		</convertAgeToFormattedTime>
		<shuffle public="1" params="T" set="method">
			<f a="array">
				<c path="Array"><c path="shuffle.T"/></c>
				<c path="Array"><c path="shuffle.T"/></c>
			</f>
			<haxe_doc>
	 * Randomly sorts an array.
	 </haxe_doc>
		</shuffle>
		<getRandomType public="1" params="T" set="method">
			<f a="e">
				<c path="Enum"><c path="getRandomType.T"/></c>
				<c path="getRandomType.T"/>
			</f>
			<haxe_doc>
	 * Creates any enumerator from the supplied class. 
	 </haxe_doc>
		</getRandomType>
		<intToHex public="1" set="method">
			<f a="value">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Converts an Int to a Hex string.
	 * @param	value	The Int to convert.
	 * @return	Hex value.
	 </haxe_doc>
		</intToHex>
		<serialize public="1" set="method">
			<f a="value">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Converts an object into a serialized string.
	 * @param	value	The object to convert.
	 * @return	The serialized object.
	 </haxe_doc>
		</serialize>
		<unserialize public="1" set="method">
			<f a="value">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	 * Restores an object from a serialized string.
	 * @param	value	The serialised object.
	 * @return	The object to restore.
	 </haxe_doc>
		</unserialize>
		<haxe_doc><![CDATA[
 * The ITools interface should be implemented by objects intended to provide tool box functionality.
 * <p>Many of these tools are need in the minimalist implementation of the interfaces.</p>
 * <p>The other functions are often regularly used in entity creation.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.Tools" params="" file="src/awe6/core/Tools.hx">
		<implements path="awe6.interfaces.ITools"/>
		<BIG_NUMBER public="1" set="null"><c path="Int"/></BIG_NUMBER>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_encrypter><c path="awe6.interfaces.IEncrypter"/></_encrypter>
		<createGuid public="1" set="method" line="59"><f a="?p_isSmall:?p_prefix">
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
</f></createGuid>
		<_randomCharacter set="method" line="64"><f a=""><c path="String"/></f></_randomCharacter>
		<ease public="1" get="inline" set="null" line="69"><f a="p_originalValue:p_newValue:p_ease">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<sortByString public="1" get="inline" set="null" line="74"><f a="p_a:p_b">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
</f></sortByString>
		<sortByInt public="1" get="inline" set="null" line="79"><f a="p_a:p_b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></sortByInt>
		<sortByPriority public="1" get="inline" set="null" line="84"><f a="p_a:p_b">
	<c path="awe6.interfaces.IPriority"/>
	<c path="awe6.interfaces.IPriority"/>
	<c path="Int"/>
</f></sortByPriority>
		<toUpperCaseFirst public="1" get="inline" set="null" line="99"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></toUpperCaseFirst>
		<_isCamelCase set="method" line="104"><f a="p_value">
	<c path="String"/>
	<e path="Bool"/>
</f></_isCamelCase>
		<_isConstCase set="method" line="121"><f a="p_value">
	<c path="String"/>
	<e path="Bool"/>
</f></_isConstCase>
		<toCamelCase public="1" set="method" line="134"><f a="p_value:?p_isUpper">
	<c path="String"/>
	<e path="Bool"/>
	<c path="String"/>
</f></toCamelCase>
		<fromCamelCase public="1" set="method" line="164"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></fromCamelCase>
		<toConstCase public="1" set="method" line="185"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></toConstCase>
		<fromConstCase public="1" set="method" line="209"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></fromConstCase>
		<toWords public="1" set="method" line="226"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></toWords>
		<limit public="1" get="inline" set="null" line="239"><f a="p_value:p_min:p_max">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></limit>
		<range public="1" get="inline" set="null" line="244"><f a="p_value:p_min:p_max">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></range>
		<swap public="1" params="T" get="inline" set="null" line="258"><f a="p_a:p_b">
	<c path="swap.T"/>
	<c path="swap.T"/>
	<e path="Void"/>
</f></swap>
		<getRandomType public="1" params="T" set="method" line="265"><f a="p_enum">
	<c path="Enum"><c path="getRandomType.T"/></c>
	<c path="getRandomType.T"/>
</f></getRandomType>
		<isOdd public="1" get="inline" set="null" line="270"><f a="p_value">
	<c path="Int"/>
	<e path="Bool"/>
</f></isOdd>
		<isEven public="1" get="inline" set="null" line="275"><f a="p_value">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEven>
		<sgn public="1" get="inline" set="null" line="280"><f a="p_value">
	<c path="Float"/>
	<c path="Int"/>
</f></sgn>
		<isBool public="1" get="inline" set="null" line="296"><f a="p_value">
	<d/>
	<e path="Bool"/>
</f></isBool>
		<nearestSquare public="1" get="inline" set="null" line="301"><f a="p_value">
	<c path="Float"/>
	<c path="Int"/>
</f></nearestSquare>
		<shuffle public="1" params="T" set="method" line="314"><f a="p_array">
	<c path="Array"><c path="shuffle.T"/></c>
	<c path="Array"><c path="shuffle.T"/></c>
</f></shuffle>
		<convertUpdatesToFormattedTime public="1" set="method" line="329"><f a="p_updates:?p_delimiter">
	<c path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></convertUpdatesToFormattedTime>
		<convertAgeToFormattedTime public="1" set="method" line="335"><f a="p_age:?p_delimiter">
	<c path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></convertAgeToFormattedTime>
		<intToHex public="1" get="inline" set="null" line="383"><f a="p_value">
	<c path="Int"/>
	<c path="String"/>
</f></intToHex>
		<serialize public="1" get="inline" set="null" line="390"><f a="p_value">
	<d/>
	<c path="String"/>
</f></serialize>
		<unserialize public="1" get="inline" set="null" line="395"><f a="p_value">
	<c path="String"/>
	<d/>
</f></unserialize>
		<encrypt public="1" set="method" line="400"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></encrypt>
		<decrypt public="1" set="method" line="405"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></decrypt>
		<new public="1" set="method" line="52"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The Tools class provides a minimalist implementation of the ITools interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<typedef path="awe6.core.View" params="" file="src/awe6/core/View.hx">
		<c path="awe6.core.drivers.flash.View"/>
		<haxe_doc><![CDATA[
 * The View class provides a minimalist implementation of the IView interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>Kernel includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="flash.system.ApplicationDomain" params="" file="C:\Motion-Twin\haxe/std/flash9/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1"><t path="UInt"/></MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<domainMemory public="1"><c path="flash.utils.ByteArray"/></domainMemory>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Std.hx">
		<is public="1" set="method" line="28" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="32" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="36" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="40" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="51" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<class path="flash.display.FrameLabel" params="" file="C:\Motion-Twin\haxe/std/flash9/display/FrameLabel.hx" extern="1">
		<frame public="1" set="null"><c path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.interfaces.IFactory" params="" file="src/awe6/interfaces/IFactory.hx" interface="1">
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc><![CDATA[
	 * The unique identifier for this specific project.  <=16 chars, no spaces.
	 ]]></haxe_doc>
		</id>
		<version public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The current version of this specific project.  Suggestion: major.minor.revision - e.g. 1.2.345
	 </haxe_doc>
		</version>
		<author public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The author or this specific project.
	 </haxe_doc>
		</author>
		<isDebug public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * A convenient switch to allow debug modes or verbose output in your code.  Adjust as needed.
	 </haxe_doc>
		</isDebug>
		<isDecached public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * A convenient switch to force all loaded content to be freshly loaded each request (rather than caching).
	 </haxe_doc>
		</isDecached>
		<isEyeCandyOptionEnabled public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Disable to hide any eye candy options.
	 </haxe_doc>
		</isEyeCandyOptionEnabled>
		<isFullScreenOptionEnabled public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Disable to hide any full screen options.
	 </haxe_doc>
		</isFullScreenOptionEnabled>
		<isResetSessionsOptionEnabled public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Disable to hide any session resetting options.
	 </haxe_doc>
		</isResetSessionsOptionEnabled>
		<width public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The horizontal width of this application's bounding rectangle.
	 </haxe_doc>
		</width>
		<height public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The vertical height of this application's bounding rectangle.
	 </haxe_doc>
		</height>
		<bgColor public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The default background color of the application's bounding rectangle.
	 </haxe_doc>
		</bgColor>
		<fullScreenType public="1" set="null">
			<e path="awe6.interfaces.EFullScreen"/>
			<haxe_doc>
	 * The default scaling used for fullScreen mode.
	 </haxe_doc>
		</fullScreenType>
		<secret public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The default secret key used to encrypt data.  Set it to something specific for your project, and conceal it's value.
	 </haxe_doc>
		</secret>
		<targetFramerate public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The intended frequency of the update broad phase traversal stack.  Technical limitations may prevent desired framerate from occurring.
	 </haxe_doc>
		</targetFramerate>
		<isFixedUpdates public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * If true will send the time between each update as if the targetFramerate was hit perfectly.  If false will send the actual time between each update (which will vary from update to update).
	 </haxe_doc>
		</isFixedUpdates>
		<config public="1" set="null">
			<c path="Hash"><d/></c>
			<haxe_doc>
	 * Dictionary of values.  Can be used to load initial configuration settings or store global variables.
	 </haxe_doc>
		</config>
		<startingSceneType public="1" set="null">
			<e path="awe6.interfaces.EScene"/>
			<haxe_doc>
	 * The scene which is displayed first.  The application starts here.
	 </haxe_doc>
		</startingSceneType>
		<keyPause public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>
	 * The default key used in this application to pause updates.
	 </haxe_doc>
		</keyPause>
		<keyMute public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>
	 * The default key used in this application to mute the audio.
	 </haxe_doc>
		</keyMute>
		<keyBack public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>
	 * The default key used in this application to back out of the current scene.
	 </haxe_doc>
		</keyBack>
		<keyNext public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>
	 * The default key used in this application to advance to the next scene.
	 </haxe_doc>
		</keyNext>
		<keySpecial public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>
	 * The default key used in this application to do a special action (determined by the specific application).
	 </haxe_doc>
		</keySpecial>
		<onInitComplete public="1" set="method">
			<f a="kernel">
				<c path="awe6.interfaces.IKernel"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called by the kernel to complete initialization (due to both requiring an initialized instance of each).
	 * @param	kernel	An intialized kernel offering services to the factory.
	 </haxe_doc>
		</onInitComplete>
		<createAssetManager public="1" set="method">
			<f a=""><c path="awe6.interfaces.IAssetManagerProcess"/></f>
			<haxe_doc>
	 * Builds the application's asset manager which store images, sounds etc.
	 * @return	Asset manager.
	 </haxe_doc>
		</createAssetManager>
		<createEncrypter public="1" set="method">
			<f a=""><c path="awe6.interfaces.IEncrypter"/></f>
			<haxe_doc>
	 * Builds the application's encrypter to encrypt sensitive data / assets.
	 * @return Encrypter to encrypt sensitive data / assets.
	 </haxe_doc>
		</createEncrypter>
		<createEntity public="1" set="method">
			<f a="?id">
				<c path="String"/>
				<c path="awe6.interfaces.IEntity"/>
			</f>
			<haxe_doc>
	 * Builds an empty Entity for injection.
	 * @param	?id	The unique identifier of this entity.
	 * @return	An empty Entity.
	 </haxe_doc>
		</createEntity>
		<createLogger public="1" set="method">
			<f a=""><c path="awe6.interfaces.ILogger"/></f>
			<haxe_doc>
	 * Builds the application's logger to log events / analytics.
	 * @return	Logger to log events / analytics.
	 </haxe_doc>
		</createLogger>
		<createOverlay public="1" set="method">
			<f a=""><c path="awe6.interfaces.IOverlayProcess"/></f>
			<haxe_doc>
	 * Builds the application's overlay to decorate and provide top level functionality.
	 * @return	Overlay to decorate and provide top level functionality.
	 </haxe_doc>
		</createOverlay>
		<createPreloader public="1" set="method">
			<f a=""><c path="awe6.interfaces.IPreloader"/></f>
			<haxe_doc>
	 * Builds the application's preloader to load initial media assets.
	 * @return	Preloader to load initial media assets.
	 </haxe_doc>
		</createPreloader>
		<createScene public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<c path="awe6.interfaces.IScene"/>
			</f>
			<haxe_doc>
	 * Builds the application's scenes which contain specific functionality.
	 * @param	type	The type of scene.
	 * @return	Scene which contain specific functionality.
	 </haxe_doc>
		</createScene>
		<createSceneTransition public="1" set="method">
			<f a="?typeIncoming:?typeOutgoing">
				<e path="awe6.interfaces.EScene"/>
				<e path="awe6.interfaces.EScene"/>
				<c path="awe6.interfaces.ISceneTransition"/>
			</f>
			<haxe_doc>
	 * Builds the application's transition between scenes.  Can be individually tailored for any combination of incoming and outgoing scene.
	 * @param	?typeIncoming	The type of the incoming scene.
	 * @param	?typeOutgoing	The type of the outgoing scene.
	 * @return	Transition between scenes.
	 </haxe_doc>
		</createSceneTransition>
		<createSession public="1" set="method">
			<f a="?id">
				<c path="String"/>
				<c path="awe6.interfaces.ISession"/>
			</f>
			<haxe_doc>
	 * Builds the application's session to store user progress.
	 * @param	id	The unique identifier of the session.  If session already exists will load existing.
	 * @return	Session to store user progress.
	 </haxe_doc>
		</createSession>
		<createTextStyle public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.ETextStyle"/>
				<c path="awe6.interfaces.ITextStyle"/>
			</f>
			<haxe_doc>
	 * Builds the application's textStyle to configure font formatting.
	 * @param	?type	The type of textStyle.
	 * @return	TextStyle to configure font formatting.
	 </haxe_doc>
		</createTextStyle>
		<getBackSceneType public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<e path="awe6.interfaces.EScene"/>
			</f>
			<haxe_doc>
	 * When a scene is backed out of it will be replaced by the scene returned here.
	 * @param	type	Type of scene to back out from.
	 * @return	Scene type to back out to.
	 </haxe_doc>
		</getBackSceneType>
		<getNextSceneType public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<e path="awe6.interfaces.EScene"/>
			</f>
			<haxe_doc>
	 * When a scene requests the next scene it will be replaced by the scene returned here.
	 * @param	type	Type of scene to advance from.
	 * @return	Scene type to advance to next.
	 </haxe_doc>
		</getNextSceneType>
		<haxe_doc><![CDATA[
 * The IFactory interface should be implemented by objects designed to populate an awe6 implementation.
 * <p>The IFactory represents the blueprint and builder for all project specific classes.</p>
 * @author Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AFactory" params="" file="src/awe6/core/drivers/AFactory.hx">
		<implements path="awe6.interfaces.IDisposable"/>
		<implements path="awe6.interfaces.IFactory"/>
		<_CONFIG_ASSETS_NODE get="inline" set="null" line="68" static="1"><c path="String"/></_CONFIG_ASSETS_NODE>
		<_context><t path="awe6.core.Context"/></_context>
		<_config><c path="String"/></_config>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_concreteKernel><t path="awe6.core.Kernel"/></_concreteKernel>
		<_tools><c path="awe6.interfaces.ITools"/></_tools>
		<isDisposed public="1" set="null"><e path="Bool"/></isDisposed>
		<id public="1" set="null"><c path="String"/></id>
		<version public="1" set="null"><c path="String"/></version>
		<author public="1" set="null"><c path="String"/></author>
		<isDebug public="1" set="null"><e path="Bool"/></isDebug>
		<isDecached public="1" set="null"><e path="Bool"/></isDecached>
		<isEyeCandyOptionEnabled public="1" set="null"><e path="Bool"/></isEyeCandyOptionEnabled>
		<isFullScreenOptionEnabled public="1" set="null"><e path="Bool"/></isFullScreenOptionEnabled>
		<isResetSessionsOptionEnabled public="1" set="null"><e path="Bool"/></isResetSessionsOptionEnabled>
		<width public="1" set="null"><c path="Int"/></width>
		<height public="1" set="null"><c path="Int"/></height>
		<bgColor public="1" set="null"><c path="Int"/></bgColor>
		<fullScreenType public="1" set="null"><e path="awe6.interfaces.EFullScreen"/></fullScreenType>
		<secret public="1" set="null"><c path="String"/></secret>
		<targetFramerate public="1" set="null"><c path="Int"/></targetFramerate>
		<isFixedUpdates public="1" set="null"><e path="Bool"/></isFixedUpdates>
		<config public="1" set="null"><c path="Hash"><d/></c></config>
		<startingSceneType public="1" set="null"><e path="awe6.interfaces.EScene"/></startingSceneType>
		<keyPause public="1" set="null"><e path="awe6.interfaces.EKey"/></keyPause>
		<keyMute public="1" set="null"><e path="awe6.interfaces.EKey"/></keyMute>
		<keyBack public="1" set="null"><e path="awe6.interfaces.EKey"/></keyBack>
		<keyNext public="1" set="null"><e path="awe6.interfaces.EKey"/></keyNext>
		<keySpecial public="1" set="null"><e path="awe6.interfaces.EKey"/></keySpecial>
		<_init get="inline" set="null" line="108"><f a=""><e path="Void"/></f></_init>
		<_driverInit set="method" line="117"><f a=""><e path="Void"/></f></_driverInit>
		<_traverseElements set="method" line="128"><f a="p_elements:p_prefix">
	<t path="Iterator"><c path="Xml"/></t>
	<c path="String"/>
	<e path="Void"/>
</f></_traverseElements>
		<_configure get="inline" set="null" line="160"><f a=""><e path="Void"/></f></_configure>
		<_configurer set="method" line="185"><f a=""><e path="Void"/></f></_configurer>
		<_launchKernel set="method" line="190"><f a=""><e path="Void"/></f></_launchKernel>
		<_getAssetUrls set="method" line="199"><f a=""><c path="Array"><c path="String"/></c></f></_getAssetUrls>
		<onInitComplete public="1" set="method" line="213"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></onInitComplete>
		<createAssetManager public="1" set="method" line="226"><f a=""><c path="awe6.interfaces.IAssetManagerProcess"/></f></createAssetManager>
		<createEncrypter public="1" set="method" line="238"><f a=""><c path="awe6.interfaces.IEncrypter"/></f></createEncrypter>
		<createEntity public="1" set="method" line="243"><f a="?p_id">
	<c path="String"/>
	<c path="awe6.interfaces.IEntity"/>
</f></createEntity>
		<createLogger public="1" set="method" line="248"><f a=""><c path="awe6.interfaces.ILogger"/></f></createLogger>
		<createOverlay public="1" set="method" line="253"><f a=""><c path="awe6.interfaces.IOverlayProcess"/></f></createOverlay>
		<createPreloader public="1" set="method" line="258"><f a=""><c path="awe6.interfaces.IPreloader"/></f></createPreloader>
		<createScene public="1" set="method" line="263"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<c path="awe6.interfaces.IScene"/>
</f></createScene>
		<createSceneTransition public="1" set="method" line="272"><f a="?p_typeIncoming:?p_typeOutgoing">
	<e path="awe6.interfaces.EScene"/>
	<e path="awe6.interfaces.EScene"/>
	<c path="awe6.interfaces.ISceneTransition"/>
</f></createSceneTransition>
		<createSession public="1" set="method" line="277"><f a="?p_id">
	<c path="String"/>
	<c path="awe6.interfaces.ISession"/>
</f></createSession>
		<createTextStyle public="1" set="method" line="282"><f a="?p_type">
	<e path="awe6.interfaces.ETextStyle"/>
	<c path="awe6.interfaces.ITextStyle"/>
</f></createTextStyle>
		<getBackSceneType public="1" set="method" line="287"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<e path="awe6.interfaces.EScene"/>
</f></getBackSceneType>
		<getNextSceneType public="1" set="method" line="292"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<e path="awe6.interfaces.EScene"/>
</f></getNextSceneType>
		<dispose public="1" set="method" line="297"><f a=""><e path="Void"/></f></dispose>
		<_driverDisposer set="method" line="313"><f a=""><e path="Void"/></f></_driverDisposer>
		<new public="1" set="method" line="100"><f a="p_context:?p_isDebug:?p_config">
	<t path="awe6.core.Context"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The AFactory class provides a minimalist abstract implementation of the IFactory interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.flash.Factory" params="" file="src/awe6/core/drivers/flash/Factory.hx">
		<extends path="awe6.core.drivers.AFactory"/>
		<_CONFIG_URL get="inline" set="null" line="46" static="1"><c path="String"/></_CONFIG_URL>
		<_CONFIG_JOIN_NODE get="inline" set="null" line="47" static="1"><c path="String"/></_CONFIG_JOIN_NODE>
		<_countConfigsLoaded><c path="Int"/></_countConfigsLoaded>
		<_countConfigsToLoad><c path="Int"/></_countConfigsToLoad>
		<_driverInit set="method" line="52" override="1"><f a=""><e path="Void"/></f></_driverInit>
		<_hasStage set="method" line="69"><f a="?p_event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></_hasStage>
		<_loadConfig set="method" line="88"><f a="p_config">
	<c path="String"/>
	<e path="Void"/>
</f></_loadConfig>
		<_parseXml set="method" line="108"><f a="p_data">
	<c path="String"/>
	<e path="Void"/>
</f></_parseXml>
		<_onIOError set="method" line="128"><f a="p_event">
	<c path="flash.events.IOErrorEvent"/>
	<e path="Void"/>
</f></_onIOError>
		<_onComplete set="method" line="143"><f a="p_event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></_onComplete>
		<_driverDisposer set="method" line="154" override="1"><f a=""><e path="Void"/></f></_driverDisposer>
		<new public="1" set="method" line="44"><f a="p_context:?p_isDebug:?p_config">
	<t path="awe6.core.Context"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This Factory class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\Motion-Twin\haxe/std/flash9/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.utils.QName" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/QName.hx" extern="1">
		<localName public="1" set="null"><c path="String"/></localName>
		<uri public="1" set="null"><d/></uri>
		<new public="1" set="method"><f a="?namespace:?name">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.interfaces.IOverlay" params="" file="src/awe6/interfaces/IOverlay.hx" interface="1">
		<pauseEntity public="1" get="_get_pauseEntity" set="_set_pauseEntity">
			<c path="awe6.interfaces.IEntity"/>
			<haxe_doc>
	 * An optional IEntity which is displayed and updated when the game is paused.
	 </haxe_doc>
		</pauseEntity>
		<showButton public="1" set="method">
			<f a="type:?isVisible">
				<e path="awe6.interfaces.EOverlayButton"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the visibility of a specific overlay button.
	 * @param	type	The overlay button.
	 * @param	?isVisible	If true shows the button, if false hides it.
	 </haxe_doc>
		</showButton>
		<positionButton public="1" set="method">
			<f a="type:x:y">
				<e path="awe6.interfaces.EOverlayButton"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the position of a specific overlay button.
	 * @param	type	The overlay button.
	 * @param	x	The horizontal position.
	 * @param	y	The vertical position.
	 </haxe_doc>
		</positionButton>
		<activateButton public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EOverlayButton"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Triggers an overlay button (as if it was clicked on).
	 * @param	type	The overlay button.
	 </haxe_doc>
		</activateButton>
		<showProgress public="1" set="method">
			<f a="progress:?message">
				<c path="Float"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Simple representation of progress.
	 * @param	progress	Range: 0...1.
	 * @param	?message	An optional string to display.
	 </haxe_doc>
		</showProgress>
		<hideButtons public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Hides all overlay buttons.
	 </haxe_doc>
		</hideButtons>
		<flash public="1" set="method">
			<f a="?duration:?asTime:?startingAlpha:?color">
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a flash over the top of everything under the overlay.  Fades to invisible over a period of time.
	 * @param	?duration	The period of time over which the flash should fade to 0.
	 * @param	?asTime	If true treats the time as milliseconds, otherwise as frame updates.
	 * @param	?startingAlpha	The alpha at which the flash starts.  Range: 0...1.
	 * @param	?color	The color of the flash.  Defaults to white.
	 </haxe_doc>
		</flash>
		<haxe_doc><![CDATA[
 * The IOverlay interface should be implemented by objects representing the top most visual element of the application.
 * <p>The overlay is intended to provide application wide border / chrome with controls such as back, mute, pause etc.</p>
 * <p>The overlay also provides flashing which is a useful cheap effect across many game scenarios.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IInputJoypad" params="" file="src/awe6/interfaces/IInputJoypad.hx" interface="1">
		<getIsButtonDown public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EJoypadButton"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine if a specific joypad button is currently down.
	 * @param	type	The joypad button.
	 * @return	Returns true is the joypad button is currently down, false otherwise.
	 </haxe_doc>
		</getIsButtonDown>
		<getIsButtonPress public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EJoypadButton"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine if a specific joypad button was pressed in the current update frame.
	 * <p>A press is defined as a new down - i.e. was up previous frame, and is down this frame.</p>
	 * @param	type	The joypad button.
	 * @return	Returns true is the joypad button was pressed in the current update, false otherwise.
	 ]]></haxe_doc>
		</getIsButtonPress>
		<getIsButtonRelease public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EJoypadButton"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine if a specific joypad button was released in the current update.
	 * <p>A release is defined as a new up - i.e. was down previous frame, and is up this frame.</p>
	 * @param	type	The joypad button.
	 * @return	Returns true is the joypad button was released in the current update, false otherwise.
	 ]]></haxe_doc>
		</getIsButtonRelease>
		<getButtonDownDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EJoypadButton"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Determine how long a specific joypad button has been down.
	 * @param	type	The joypad button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration down (the time held prior to the most recent release).
	 * @return	Returns the duration the joypad button has been down.
	 </haxe_doc>
		</getButtonDownDuration>
		<getButtonUpDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EJoypadButton"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Determine how long a specific joypad button has been up.
	 * @param	type	The joypad button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration up (the time unused prior to the most recent press).
	 * @return	Returns the duration the joypad button has been up.
	 </haxe_doc>
		</getButtonUpDuration>
		<haxe_doc><![CDATA[
 * The IInputJoypad interface should be implemented by an object wishing to be used as a directional pad plus two fire button joypad.
 * <p>A joypad is useful for a simple game input device.  The device is limited to 6 EJoypadButtons to prevent keyboard lock and overly complex game controls.</p>
 * <p>A joypad can be configured to accept bespoke key configurations, or alternative user interface control devices (e.g. mouse or touchpad).</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.InputJoypad" params="" file="src/awe6/core/InputJoypad.hx">
		<implements path="awe6.interfaces.IInputJoypad"/>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_keyUp><e path="awe6.interfaces.EKey"/></_keyUp>
		<_keyRight><e path="awe6.interfaces.EKey"/></_keyRight>
		<_keyDown><e path="awe6.interfaces.EKey"/></_keyDown>
		<_keyLeft><e path="awe6.interfaces.EKey"/></_keyLeft>
		<_keyPrimary><e path="awe6.interfaces.EKey"/></_keyPrimary>
		<_keySecondary><e path="awe6.interfaces.EKey"/></_keySecondary>
		<_keyUpAlt><e path="awe6.interfaces.EKey"/></_keyUpAlt>
		<_keyRightAlt><e path="awe6.interfaces.EKey"/></_keyRightAlt>
		<_keyDownAlt><e path="awe6.interfaces.EKey"/></_keyDownAlt>
		<_keyLeftAlt><e path="awe6.interfaces.EKey"/></_keyLeftAlt>
		<_keyPrimaryAlt><e path="awe6.interfaces.EKey"/></_keyPrimaryAlt>
		<_keySecondaryAlt><e path="awe6.interfaces.EKey"/></_keySecondaryAlt>
		<_check set="method" line="74"><f a="p_type:p_function">
	<e path="awe6.interfaces.EJoypadButton"/>
	<f a="">
		<e path="awe6.interfaces.EKey"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></_check>
		<getIsButtonDown public="1" set="method" line="88"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<e path="Bool"/>
</f></getIsButtonDown>
		<getIsButtonPress public="1" set="method" line="93"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<e path="Bool"/>
</f></getIsButtonPress>
		<getIsButtonRelease public="1" set="method" line="98"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<e path="Bool"/>
</f></getIsButtonRelease>
		<getButtonDownDuration public="1" set="method" line="103"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EJoypadButton"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></getButtonDownDuration>
		<getButtonUpDuration public="1" set="method" line="118"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EJoypadButton"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></getButtonUpDuration>
		<new public="1" set="method" line="57"><f a="p_kernel:p_up:p_right:p_down:p_left:p_primary:p_secondary:p_upAlt:p_rightAlt:p_downAlt:p_leftAlt:p_primaryAlt:p_secondaryAlt">
	<c path="awe6.interfaces.IKernel"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The InputJoypad class provides a minimalist implementation of the IInputJoypad interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.text.Font" params="" file="C:\Motion-Twin\haxe/std/flash9/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFormatAlign.hx">
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<CENTER/>
	</enum>
	<class path="flash.geom.Matrix" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Matrix.hx" extern="1">
		<a public="1"><c path="Float"/></a>
		<b public="1"><c path="Float"/></b>
		<c public="1"><c path="Float"/></c>
		<d public="1"><c path="Float"/></d>
		<tx public="1"><c path="Float"/></tx>
		<ty public="1"><c path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<copyColumnFrom public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1"><f a="sourceMatrix">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<setTo public="1"><f a="aa:ba:ca:da:txa:tya">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="awe6.interfaces.EKey" params="" file="src/awe6/interfaces/EKey.hx">
		<Z/>
		<Y/>
		<X/>
		<W/>
		<V/>
		<UP/>
		<U/>
		<TOPLEFT/>
		<TILDE/>
		<TAB/>
		<T/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EKey to be extended (e.g. for using non US / English keyboards).
	 </haxe_doc>
		</SUB_TYPE>
		<SQUARERIGHT/>
		<SQUARELEFT/>
		<SPACE/>
		<SLASH/>
		<SHIFT/>
		<S/>
		<RIGHT/>
		<R/>
		<Q/>
		<PAGE_UP/>
		<PAGE_DOWN/>
		<P/>
		<O/>
		<NUM_LOCK/>
		<NUMPAD_SUBTRACT/>
		<NUMPAD_MULTIPLY/>
		<NUMPAD_ENTER/>
		<NUMPAD_DIVIDE/>
		<NUMPAD_DECIMAL/>
		<NUMPAD_ADD/>
		<NUMPAD_9/>
		<NUMPAD_8/>
		<NUMPAD_7/>
		<NUMPAD_6/>
		<NUMPAD_5/>
		<NUMPAD_4/>
		<NUMPAD_3/>
		<NUMPAD_2/>
		<NUMPAD_1/>
		<NUMPAD_0/>
		<NUMBER_9/>
		<NUMBER_8/>
		<NUMBER_7/>
		<NUMBER_6/>
		<NUMBER_5/>
		<NUMBER_4/>
		<NUMBER_3/>
		<NUMBER_2/>
		<NUMBER_1/>
		<NUMBER_0/>
		<N/>
		<M/>
		<LEFT/>
		<L/>
		<K/>
		<J/>
		<INSERT/>
		<I/>
		<HYPHEN/>
		<HOME/>
		<HELP/>
		<H/>
		<G/>
		<F9/>
		<F8/>
		<F7/>
		<F6/>
		<F5/>
		<F4/>
		<F3/>
		<F2/>
		<F15/>
		<F14/>
		<F13/>
		<F12/>
		<F11/>
		<F10/>
		<F1/>
		<F/>
		<ESCAPE/>
		<EQUALS/>
		<ENTER/>
		<END/>
		<E/>
		<DOWN/>
		<DELETE/>
		<D/>
		<CONTROL/>
		<COLON/>
		<CLEAR/>
		<CAPS_LOCK/>
		<C/>
		<BACKSPACE/>
		<BACKSLASH/>
		<B/>
		<APOSTROPHE/>
		<ALT/>
		<A/>
		<haxe_doc><![CDATA[
 * Representing the keys on a Keyboard for use in the IInputKeyboard virtual controller.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<class path="awe6.interfaces.IInputMouse" params="" file="src/awe6/interfaces/IInputMouse.hx" interface="1">
		<x public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The horizontal component of the mouse position.
	 </haxe_doc>
		</x>
		<y public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The vertical component of the mouse position.
	 </haxe_doc>
		</y>
		<relativeX public="1" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The horizontal position of the mouse relative to screen width.  Range 0...1.
	 </haxe_doc>
		</relativeX>
		<relativeY public="1" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The vertical position of the mouse relative to screen height.  Range 0...1.
	 </haxe_doc>
		</relativeY>
		<relativeCentralisedX public="1" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The horizontal position of the mouse relative to screen width and offset to screen centre.  Range -1...1.
	 </haxe_doc>
		</relativeCentralisedX>
		<relativeCentralisedY public="1" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The vertical position of the mouse relative to screen height and offset to screen centre.  Range -1...1.
	 </haxe_doc>
		</relativeCentralisedY>
		<isWithinBounds public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Returns true if the mouse position is within the bounding rectangle (factory width x factory height).
	 </haxe_doc>
		</isWithinBounds>
		<isMoving public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Returns true if the mouse position is different to the previous update's position.
	 </haxe_doc>
		</isMoving>
		<isVisible public="1" set="_set_isVisible">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Specify the visibility of the mouse cursor.
	 * <p>If true the cursor will be displayed, if false the cursor is hidden.</p>
	 ]]></haxe_doc>
		</isVisible>
		<scroll public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * The current scroll position.  Starts at 0.  Range -infinity...infinity.
	 </haxe_doc>
		</scroll>
		<cursorType public="1" set="_set_cursorType">
			<e path="awe6.interfaces.EMouseCursor"/>
			<haxe_doc>
	 * The current cursor type.
	 </haxe_doc>
		</cursorType>
		<getDeltaX public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * The horizontal velocity of the mouse position.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as pixels moved in previous update.
	 * @return	The horizontal velocity of the mouse.
	 </haxe_doc>
		</getDeltaX>
		<getDeltaY public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * The vertical velocity of the mouse position.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as pixels moved in previous update.
	 * @return	The vertical velocity of the mouse.
	 </haxe_doc>
		</getDeltaY>
		<getSpeed public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * The velocity of the mouse.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as pixels moved in previous update.
	 * @return	The velocity of the mouse.
	 </haxe_doc>
		</getSpeed>
		<getDeltaScroll public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * The velocity of scrolling.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as scroll moved in previous update.
	 * @return	The scroll velocity of the mouse.
	 </haxe_doc>
		</getDeltaScroll>
		<getStillDuration public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Determine how long the mouse has been still.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @return	Returns the duration the mouse has been still.
	 </haxe_doc>
		</getStillDuration>
		<getIsButtonDoubleClick public="1" set="method">
			<f a="?type:?delay">
				<e path="awe6.interfaces.EMouseButton"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine if a specific mouse button was clicked twice (within the defined time).
	 * @param	?type	The mouse button.
	 * @param	?delay	The time within which the mouse button must be clicked twice.
	 * @return	Returns true if the mouse button was clicked twice (within the defined time).
	 </haxe_doc>
		</getIsButtonDoubleClick>
		<getIsButtonDrag public="1" set="method">
			<f a="?type:?delay">
				<e path="awe6.interfaces.EMouseButton"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine if the mouse is being dragged with a specific mouse button down (for at least the defined delay).
	 * @param	?type	The mouse button.
	 * @param	?delay	The time which, if exceeded, assumes the mouse is being dragged. 
	 * @return	Returns true if the mouse button was down for a duration exceeding delay.
	 </haxe_doc>
		</getIsButtonDrag>
		<getIsButtonDown public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine if a specific mouse button is currently down.
	 * @param	?type	The mouse button.
	 * @return	Returns true is the mouse button is currently down, false otherwise.
	 </haxe_doc>
		</getIsButtonDown>
		<getIsButtonPress public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine if a specific mouse button was pressed in the current update frame.
	 * <p>A press is defined as a new down - i.e. was up previous frame, and is down this frame.</p>
	 * @param	type	The mouse button.
	 * @return	Returns true is the mouse button was pressed in the current update, false otherwise.
	 ]]></haxe_doc>
		</getIsButtonPress>
		<getIsButtonRelease public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine if a specific mouse button was released in the current update.
	 * <p>A release is defined as a new up - i.e. was down previous frame, and is up this frame.</p>
	 * @param	type	The mouse button.
	 * @return	Returns true is the mouse button was released in the current update, false otherwise.
	 ]]></haxe_doc>
		</getIsButtonRelease>
		<getButtonDownDuration public="1" set="method">
			<f a="?type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EMouseButton"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Determine the duration a specific mouse button is down.
	 * @param	?type	The mouse button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration down (the time held prior to the most recent release).
	 * @return	The duration a specific mouse button is down.
	 </haxe_doc>
		</getButtonDownDuration>
		<getButtonUpDuration public="1" set="method">
			<f a="?type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EMouseButton"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Determine the duration a specific mouse button is up.
	 * @param	?type	The mouse button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration up (the time unused prior to the most recent press).
	 * @return	The duration a specific mouse button is up.
	 </haxe_doc>
		</getButtonUpDuration>
		<getButtonDragWidth public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Determine the horizontal movement of the mouse since a specific mouse button was pressed.
	 * @param	?type	The mouse button.
	 * @return	The horizontal movement of the mouse.
	 </haxe_doc>
		</getButtonDragWidth>
		<getButtonDragHeight public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Determine the vertical movement of the mouse since a specific mouse button was pressed.
	 * @param	?type	The mouse button.
	 * @return	The vertical movement of the mouse.
	 </haxe_doc>
		</getButtonDragHeight>
		<getButtonLastClickedX public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Determine the horizontal position of the mouse when a specific mouse button was last clicked.
	 * @param	?type	The mouse button.
	 * @return	The horizontal position of the mouse.
	 </haxe_doc>
		</getButtonLastClickedX>
		<getButtonLastClickedY public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Determine the vertical position of the mouse when a specific mouse button was last clicked.
	 * @param	?type	The mouse button.
	 * @return	The vertical position of the mouse.
	 </haxe_doc>
		</getButtonLastClickedY>
		<haxe_doc><![CDATA[
 * The IInputMouse interface should be implemented by objects wishing to act as virtual mouse controllers.
 * <p>Screen bounds are based on IFactory.width & IFactory.height.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AInputMouse" params="" file="src/awe6/core/drivers/AInputMouse.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IInputMouse"/>
		<x public="1" set="null"><c path="Int"/></x>
		<y public="1" set="null"><c path="Int"/></y>
		<relativeX public="1" set="null"><c path="Float"/></relativeX>
		<relativeY public="1" set="null"><c path="Float"/></relativeY>
		<relativeCentralisedX public="1" set="null"><c path="Float"/></relativeCentralisedX>
		<relativeCentralisedY public="1" set="null"><c path="Float"/></relativeCentralisedY>
		<isWithinBounds public="1" set="null"><e path="Bool"/></isWithinBounds>
		<isMoving public="1" set="null"><e path="Bool"/></isMoving>
		<isVisible public="1" set="_set_isVisible"><e path="Bool"/></isVisible>
		<scroll public="1" set="null"><c path="Int"/></scroll>
		<cursorType public="1" set="_set_cursorType"><e path="awe6.interfaces.EMouseCursor"/></cursorType>
		<_buffer><c path="Array"><e path="Bool"/></c></_buffer>
		<_xPrev><c path="Int"/></_xPrev>
		<_yPrev><c path="Int"/></_yPrev>
		<_deltaX><c path="Int"/></_deltaX>
		<_deltaY><c path="Int"/></_deltaY>
		<_deltaTimePrev><c path="Int"/></_deltaTimePrev>
		<_deltaScroll><c path="Int"/></_deltaScroll>
		<_scrollPrev><c path="Int"/></_scrollPrev>
		<_stillUpdates><c path="Int"/></_stillUpdates>
		<_stillDuration><c path="Int"/></_stillDuration>
		<_buttonLeft><c path="awe6.core.drivers._AInputMouse._HelperButton"/></_buttonLeft>
		<_buttonMiddle><c path="awe6.core.drivers._AInputMouse._HelperButton"/></_buttonMiddle>
		<_buttonRight><c path="awe6.core.drivers._AInputMouse._HelperButton"/></_buttonRight>
		<_init set="method" line="72" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverInit set="method" line="91"><f a=""><e path="Void"/></f></_driverInit>
		<_updater set="method" line="96" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_isMiddleDown set="method" line="130"><f a=""><e path="Bool"/></f></_isMiddleDown>
		<_isRightDown set="method" line="135"><f a=""><e path="Bool"/></f></_isRightDown>
		<_isWithinBounds set="method" line="140"><f a=""><e path="Bool"/></f></_isWithinBounds>
		<_getPosition set="method" line="145"><f a=""><e path="Void"/></f></_getPosition>
		<_handleButton set="method" line="151"><f a="?p_type:p_isDown:?p_deltaTime">
	<e path="awe6.interfaces.EMouseButton"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></_handleButton>
		<_disposer set="method" line="182" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_reset set="method" line="187"><f a="?p_event">
	<d/>
	<e path="Void"/>
</f></_reset>
		<_getButton set="method" line="195"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="awe6.core.drivers._AInputMouse._HelperButton"/>
</f></_getButton>
		<getDeltaX public="1" set="method" line="209"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Int"/>
</f></getDeltaX>
		<getDeltaY public="1" set="method" line="219"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Int"/>
</f></getDeltaY>
		<getSpeed public="1" set="method" line="229"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Int"/>
</f></getSpeed>
		<getDeltaScroll public="1" set="method" line="237"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Int"/>
</f></getDeltaScroll>
		<getIsButtonDoubleClick public="1" set="method" line="247"><f a="?p_type:?p_delay">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getIsButtonDoubleClick>
		<getIsButtonDrag public="1" set="method" line="253"><f a="?p_type:?p_delay">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getIsButtonDrag>
		<getStillDuration public="1" set="method" line="259"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Int"/>
</f></getStillDuration>
		<getIsButtonDown public="1" set="method" line="264"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<e path="Bool"/>
</f></getIsButtonDown>
		<getIsButtonPress public="1" set="method" line="270"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<e path="Bool"/>
</f></getIsButtonPress>
		<getIsButtonRelease public="1" set="method" line="276"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<e path="Bool"/>
</f></getIsButtonRelease>
		<getButtonDownDuration public="1" set="method" line="282"><f a="?p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EMouseButton"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></getButtonDownDuration>
		<getButtonUpDuration public="1" set="method" line="292"><f a="?p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EMouseButton"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></getButtonUpDuration>
		<getButtonDragWidth public="1" set="method" line="302"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="Int"/>
</f></getButtonDragWidth>
		<getButtonDragHeight public="1" set="method" line="308"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="Int"/>
</f></getButtonDragHeight>
		<getButtonLastClickedX public="1" set="method" line="314"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="Int"/>
</f></getButtonLastClickedX>
		<getButtonLastClickedY public="1" set="method" line="320"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="Int"/>
</f></getButtonLastClickedY>
		<_set_isVisible set="method" line="326"><f a="p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isVisible>
		<_set_cursorType set="method" line="332"><f a="p_value">
	<e path="awe6.interfaces.EMouseCursor"/>
	<e path="awe6.interfaces.EMouseCursor"/>
</f></_set_cursorType>
		<new public="1" set="method" line="44"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The InputMouse class provides a minimalist implementation of the IInputMouse interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers._AInputMouse._HelperButton" params="" file="src/awe6/core/drivers/AInputMouse.hx" private="1" module="awe6.core.drivers.AInputMouse">
		<isDown public="1"><e path="Bool"/></isDown>
		<updatesDown public="1"><c path="Int"/></updatesDown>
		<updatesUp public="1"><c path="Int"/></updatesUp>
		<timeDown public="1"><c path="Int"/></timeDown>
		<timeUp public="1"><c path="Int"/></timeUp>
		<updatesDownPrevious public="1"><c path="Int"/></updatesDownPrevious>
		<updatesUpPrevious public="1"><c path="Int"/></updatesUpPrevious>
		<timeDownPrevious public="1"><c path="Int"/></timeDownPrevious>
		<timeUpPrevious public="1"><c path="Int"/></timeUpPrevious>
		<clickX public="1"><c path="Int"/></clickX>
		<clickY public="1"><c path="Int"/></clickY>
		<new public="1" set="method" line="354"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\Motion-Twin\haxe/std/flash9/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.filters.BlurFilter" params="" file="C:\Motion-Twin\haxe/std/flash9/filters/BlurFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<blurX public="1"><c path="Float"/></blurX>
		<blurY public="1"><c path="Float"/></blurY>
		<quality public="1"><c path="Int"/></quality>
		<new public="1" set="method"><f a="?blurX:?blurY:?quality">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.StageAlign" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
	</enum>
	<class path="flash.geom.Matrix3D" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1"><f a="column:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1"><f a="sourceMatrix3D">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></copyFrom>
		<copyRawDataFrom public="1"><f a="vector:?index:?transpose">
	<c path="flash.Vector"><c path="Float"/></c>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyRawDataFrom>
		<copyRawDataTo public="1"><f a="vector:?index:?transpose">
	<c path="flash.Vector"><c path="Float"/></c>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyRawDataTo>
		<copyRowFrom public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1"><f a="row:vector3D">
	<t path="UInt"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyRowTo>
		<copyToMatrix3D public="1"><f a="dest">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></copyToMatrix3D>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.Event" params="" file="C:\Motion-Twin\haxe/std/flash9/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1"><c path="String"/></CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<COPY public="1" static="1"><c path="String"/></COPY>
		<CUT public="1" static="1"><c path="String"/></CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1"><c path="String"/></EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1"><c path="String"/></FRAME_CONSTRUCTED>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1"><c path="String"/></PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1"><c path="String"/></SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1"><c path="String"/></TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><e path="Bool"/></altKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Hash" params="T" file="C:\Motion-Twin\haxe/std/flash9/_std/Hash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\Motion-Twin\haxe/std/flash9/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><t path="UInt"/></errno>
		<stub public="1"><e path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="EReg" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/EReg.hx">
		<r><c path="flash.utils.RegExp"/></r>
		<result><c path="+Array"/></result>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="40">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="44">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="57">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="62">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="68">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="72">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="31"><f a="r:opt">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\Motion-Twin\haxe/std/flash9/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<class path="flash.display3D.textures.TextureBase" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/textures/TextureBase.hx" extern="1"><dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose></class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
	</class>
	<class path="awe6.interfaces.ILogger" params="" file="src/awe6/interfaces/ILogger.hx" interface="1">
		<log public="1" set="method">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pass a value to the logger to log.
	 * @param	value	The value (can be anything).
	 </haxe_doc>
		</log>
		<haxe_doc><![CDATA[
 * The ILogger interface should be implemented by objects wishing to act as logging services.
 * <p>Logging services are useful for debugging or analytics.</p>
 * <p>The interface is intentionally vague to allow a multitude of implementations.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<enum path="awe6.interfaces.ETextAlign" params="" file="src/awe6/interfaces/ETextAlign.hx">
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<CENTER/>
		<haxe_doc>
 * Representing alternative horizontal text alignments for ITextStyle implementations.
 * @author	Robert Fell
 </haxe_doc>
	</enum>
	<typedef path="awe6.core.APreloader" params="" file="src/awe6/core/APreloader.hx">
		<c path="awe6.core.drivers.flash.Preloader"/>
		<haxe_doc><![CDATA[
 * The APreloader class provides a minimalist abstract implementation of the IPreloader interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>APreloader includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="flash.ui.MouseCursor" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/MouseCursor.hx" extern="1">
		<ARROW public="1" static="1"><c path="String"/></ARROW>
		<AUTO public="1" static="1"><c path="String"/></AUTO>
		<BUTTON public="1" static="1"><c path="String"/></BUTTON>
		<HAND public="1" static="1"><c path="String"/></HAND>
		<IBEAM public="1" static="1"><c path="String"/></IBEAM>
	</class>
	<class path="flash.text.TextFormat" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TextEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<errorID public="1"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.IOErrorEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Int32" params="" file="C:\Motion-Twin\haxe/std/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="29" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="33" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<clamp get="inline" set="null" line="37" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></clamp>
		<toInt public="1" get="inline" set="null" line="45" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="54" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="58" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="62" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="66" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="70" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="74" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="82" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="90" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="98" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="102" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="106" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="110" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<complement public="1" get="inline" set="null" line="114" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="118" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
		<ucompare public="1" set="method" line="129" static="1">
			<f a="a:b">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Compare two Int32 in unsigned mode.
	</haxe_doc>
		</ucompare>
	</class>
	<enum path="flash.display.CapsStyle" params="" file="C:\Motion-Twin\haxe/std/flash9/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
	</enum>
	<class path="flash.display.NativeMenu" params="" file="C:\Motion-Twin\haxe/std/flash9/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<clipboardItems public="1"><c path="flash.ui.ContextMenuClipboardItems"/></clipboardItems>
		<clipboardMenu public="1"><e path="Bool"/></clipboardMenu>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<link public="1"><c path="flash.net.URLRequest"/></link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.errors.TypeError" params="" file="C:\Motion-Twin\haxe/std/flash9/errors/TypeError.hx" extern="1"><extends path="flash.errors.Error"/></class>
	<enum path="flash.system.TouchscreenType" params="" file="C:\Motion-Twin\haxe/std/flash9/system/TouchscreenType.hx">
		<STYLUS/>
		<NONE/>
		<FINGER/>
	</enum>
	<class path="awe6.interfaces.IAssetManager" params="" file="src/awe6/interfaces/IAssetManager.hx" interface="1">
		<getAsset public="1" set="method">
			<f a="id:?packageId:?args">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
	 * Request an embedded or loaded media asset.  E.g. bitmap or sound.
	 * @param	id	The uniqie reference of the requested asset.  E.g. className.
	 * @param	?packageId	The package of the requested asset.  Will default to "assets" if not provided.
	 * @param	?args	Some assets may require additional arguments, provide them here.
	 * @return	The asset - can be of any type for type inference (or cast as appropriate).
	 </haxe_doc>
		</getAsset>
		<haxe_doc><![CDATA[
 * Provides functions to interact with media assets embedded or loaded in the application.
 * <p>Use with caution, there are usually more type safe ways to utilise assets.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IAssetManagerProcess" params="" file="src/awe6/interfaces/IAssetManagerProcess.hx" interface="1">
		<implements path="awe6.interfaces.IProcess"/>
		<implements path="awe6.interfaces.IAssetManager"/>
		<haxe_doc><![CDATA[
 * The IAssetManagerProcess interface should be implemented by objects representing an operating IAssetManager.
 * <p>These extra interface requirements are required for internal workings, but are not exposed via the minimal IAssetManager interface.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.utils.Namespace" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Namespace.hx" extern="1">
		<prefix public="1" set="null"><d/></prefix>
		<uri public="1" set="null"><c path="String"/></uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.interfaces.IProgress" params="" file="src/awe6/interfaces/IProgress.hx" interface="1">
		<progress public="1" get="_get_progress" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * Range: 0...1.  0 represents just starting, 1 represents complete.
	 </haxe_doc>
		</progress>
		<haxe_doc>
 * The IProgress interface should be implemented by objects intended to progress from start to finish ( 0...1 ).
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IPreloader" params="" file="src/awe6/interfaces/IPreloader.hx" interface="1">
		<implements path="awe6.interfaces.IProgress"/>
		<implements path="awe6.interfaces.IViewable"/>
		<implements path="awe6.interfaces.IProcess"/>
		<haxe_doc>
 * The IPreloader interface should be implemented by objects intended to act as preloaders.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.APreloader" params="" file="src/awe6/core/drivers/APreloader.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IPreloader"/>
		<view public="1" get="_get_view" set="null"><c path="awe6.interfaces.IView"/></view>
		<progress public="1" get="_get_progress" set="null"><c path="Float"/></progress>
		<_assets><c path="Array"><c path="String"/></c></_assets>
		<_isDecached><e path="Bool"/></_isDecached>
		<_encrypter><c path="awe6.interfaces.IEncrypter"/></_encrypter>
		<_currentProgress><c path="Float"/></_currentProgress>
		<_currentAsset><c path="Int"/></_currentAsset>
		<_isComplete><e path="Bool"/></_isComplete>
		<_init set="method" line="64" override="1"><f a=""><e path="Void"/></f></_init>
		<_next set="method" line="82"><f a=""><e path="Void"/></f></_next>
		<_driverLoad set="method" line="101"><f a="p_url">
	<c path="String"/>
	<e path="Void"/>
</f></_driverLoad>
		<_updater set="method" line="106" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="116" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_driverDisposer set="method" line="123"><f a=""><e path="Void"/></f></_driverDisposer>
		<_get_view set="method" line="128"><f a=""><c path="awe6.interfaces.IView"/></f></_get_view>
		<_get_progress set="method" line="133"><f a=""><c path="Float"/></f></_get_progress>
		<new public="1" set="method" line="57"><f a="p_kernel:p_assets:?p_isDecached">
	<c path="awe6.interfaces.IKernel"/>
	<c path="Array"><c path="String"/></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The APreloader class provides a minimalist abstract implementation of the IPreloader interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.flash.Preloader" params="" file="src/awe6/core/drivers/flash/Preloader.hx">
		<extends path="awe6.core.drivers.APreloader"/>
		<_context><t path="awe6.core.Context"/></_context>
		<_loader><c path="flash.display.Loader"/></_loader>
		<_urlLoader><c path="flash.net.URLLoader"/></_urlLoader>
		<_loaderContext><c path="flash.system.LoaderContext"/></_loaderContext>
		<_textField><c path="flash.text.TextField"/></_textField>
		<_swfData><t path="haxe.io.BytesData"/></_swfData>
		<_init set="method" line="61" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverLoad set="method" line="73" override="1"><f a="p_url">
	<c path="String"/>
	<e path="Void"/>
</f></_driverLoad>
		<_driverDisposer set="method" line="89" override="1"><f a=""><e path="Void"/></f></_driverDisposer>
		<_onError set="method" line="105"><f a="p_event">
	<c path="flash.events.IOErrorEvent"/>
	<e path="Void"/>
</f></_onError>
		<_onComplete set="method" line="124"><f a="?p_event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></_onComplete>
		<_onLoaderComplete set="method" line="140"><f a="p_event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></_onLoaderComplete>
		<_onProgress set="method" line="146"><f a="?p_event">
	<c path="flash.events.ProgressEvent"/>
	<e path="Void"/>
</f></_onProgress>
		<new public="1" set="method" line="52"><f a="p_kernel:p_assets:?p_isDecached">
	<c path="awe6.interfaces.IKernel"/>
	<c path="Array"><c path="String"/></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This Preloader class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.flash._Preloader._HelperSwfParser" params="" file="src/awe6/core/drivers/flash/Preloader.hx" private="1" module="awe6.core.drivers.flash.Preloader">
		<isCompressed public="1"><e path="Bool"/></isCompressed>
		<version public="1"><c path="Int"/></version>
		<width public="1"><c path="Int"/></width>
		<height public="1"><c path="Int"/></height>
		<framerate public="1"><c path="Int"/></framerate>
		<frames public="1"><c path="Int"/></frames>
		<size public="1"><c path="Int"/></size>
		<classes public="1"><c path="Array"><c path="Class"><d/></c></c></classes>
		<_data><t path="haxe.io.BytesData"/></_data>
		<_readBox set="method" line="215"><f a=""><e path="Void"/></f></_readBox>
		<_readSwfTag set="method" line="237"><f a=""><e path="Void"/></f></_readSwfTag>
		<_handleTag set="method" line="255"><f a="p_tag:p_id:p_size:p_dump">
	<t path="UInt"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></_handleTag>
		<toString public="1" set="method" line="276"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="168"><f a="p_data">
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="C:\Motion-Twin\haxe/std/flash9/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<codec public="1" set="null"><c path="String"/></codec>
		<fps public="1" set="null"><c path="Float"/></fps>
		<height public="1" set="null"><c path="Int"/></height>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<quality public="1" set="null"><c path="Int"/></quality>
		<width public="1" set="null"><c path="Int"/></width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.JointStyle" params="" file="C:\Motion-Twin\haxe/std/flash9/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
	</enum>
	<class path="flash.events.ContextMenuEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/ContextMenuEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<MENU_ITEM_SELECT public="1" static="1"><c path="String"/></MENU_ITEM_SELECT>
		<MENU_SELECT public="1" static="1"><c path="String"/></MENU_SELECT>
		<contextMenuOwner public="1"><c path="flash.display.InteractiveObject"/></contextMenuOwner>
		<isMouseTargetInaccessible public="1"><e path="Bool"/></isMouseTargetInaccessible>
		<mouseTarget public="1"><c path="flash.display.InteractiveObject"/></mouseTarget>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?mouseTarget:?contextMenuOwner">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ActivityEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/ActivityEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<ACTIVITY public="1" static="1"><c path="String"/></ACTIVITY>
		<activating public="1"><e path="Bool"/></activating>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?activating">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.DisplayObject" params="" file="C:\Motion-Twin\haxe/std/flash9/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><c path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<blendShader public="1" get="null"><c path="flash.display.Shader"/></blendShader>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><d/></c></filters>
		<height public="1"><c path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><c path="Float"/></rotation>
		<rotationX public="1"><c path="Float"/></rotationX>
		<rotationY public="1"><c path="Float"/></rotationY>
		<rotationZ public="1"><c path="Float"/></rotationZ>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleZ public="1"><c path="Float"/></scaleZ>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><e path="Bool"/></visible>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<z public="1"><c path="Float"/></z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Vector3D"/>
</f></globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<local3DToGlobal public="1" set="method"><f a="point3d">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Point"/>
</f></local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="awe6.interfaces.IScene" params="" file="src/awe6/interfaces/IScene.hx" interface="1">
		<implements path="awe6.interfaces.IViewable"/>
		<implements path="awe6.interfaces.IEntityCollection"/>
		<implements path="awe6.interfaces.IProcess"/>
		<type public="1" set="null">
			<e path="awe6.interfaces.EScene"/>
			<haxe_doc>
	 * The type of this scene.
	 </haxe_doc>
		</type>
		<isDisposable public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Sets whether the scene is disposed when no longer the active scene.  In most cases this should be true.
	 </haxe_doc>
		</isDisposable>
		<isPauseable public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Sets whether the pause button is displayed / active in the overlay.
	 </haxe_doc>
		</isPauseable>
		<isMuteable public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Sets whether the mute button is displayed / active in the overlay.
	 </haxe_doc>
		</isMuteable>
		<isSessionSavedOnNext public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Sets whether the session is automatically saved when this scene is advanced.  In most cases this should be true.
	 </haxe_doc>
		</isSessionSavedOnNext>
		<haxe_doc><![CDATA[
 * The IScene interface should be implemented by objects intending to represent scene states in the ISceneManager.
 * <p>Scenes represent the larger building blocks of the awe6 concept, and contain Entities which do the work.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.Scene" params="" file="src/awe6/core/Scene.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IScene"/>
		<type public="1" set="null"><e path="awe6.interfaces.EScene"/></type>
		<view public="1" get="_get_view" set="null"><c path="awe6.interfaces.IView"/></view>
		<isDisposable public="1" set="null"><e path="Bool"/></isDisposable>
		<isPauseable public="1" set="null"><e path="Bool"/></isPauseable>
		<isMuteable public="1" set="null"><e path="Bool"/></isMuteable>
		<isSessionSavedOnNext public="1" set="null"><e path="Bool"/></isSessionSavedOnNext>
		<_entity set="null"><c path="awe6.interfaces.IEntity"/></_entity>
		<_init set="method" line="64" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="72" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="78" override="1"><f a=""><e path="Void"/></f></_disposer>
		<addEntity public="1" set="method" line="85"><f a="p_entity:?p_agenda:?p_isAddedToView:?p_viewPriority">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addEntity>
		<removeEntity public="1" set="method" line="90"><f a="p_entity:?p_agenda:?p_isRemovedFromView">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEntity>
		<getEntities public="1" set="method" line="95"><f a="?p_agenda">
	<e path="awe6.interfaces.EAgenda"/>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></getEntities>
		<getEntitiesByClass public="1" params="T" set="method" line="100"><f a="p_classType:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="Class"><c path="getEntitiesByClass.T"/></c>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Array"><c path="getEntitiesByClass.T"/></c>
</f></getEntitiesByClass>
		<getEntityById public="1" set="method" line="105"><f a="p_id:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="String"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="awe6.interfaces.IEntity"/>
</f></getEntityById>
		<_get_view set="method" line="110"><f a=""><c path="awe6.interfaces.IView"/></f></_get_view>
		<new public="1" set="method" line="55"><f a="p_kernel:p_type:?p_isPauseable:?p_isMutable:?p_isSessionSavedOnNext">
	<c path="awe6.interfaces.IKernel"/>
	<e path="awe6.interfaces.EScene"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The Scene class provides a minimalist implementation of the IScene interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="C:\Motion-Twin\haxe/std/flash9/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
	</enum>
	<enum path="flash.ui.MultitouchInputMode" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/MultitouchInputMode.hx">
		<TOUCH_POINT/>
		<NONE/>
		<GESTURE/>
	</enum>
	<class path="haxe.FastList_awe6_core__Entity__HelperEntityAgendaPair" params="" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell_awe6_core__Entity__HelperEntityAgendaPair"/></head>
		<add public="1" get="inline" set="null" line="60">
			<f a="item">
				<c path="awe6.core._Entity._HelperEntityAgendaPair"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" get="inline" set="null" line="68">
			<f a=""><t path="Null"><c path="awe6.core._Entity._HelperEntityAgendaPair"/></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="awe6.core._Entity._HelperEntityAgendaPair"/></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" get="inline" set="null" line="90">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" set="method" line="98">
			<f a="v">
				<c path="awe6.core._Entity._HelperEntityAgendaPair"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="123">
			<f a=""><t path="Iterator"><c path="awe6.core._Entity._HelperEntityAgendaPair"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="141">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="54">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="C:\Motion-Twin\haxe/std/flash9/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
	</enum>
	<class path="awe6.interfaces.IAudioManager" params="" file="src/awe6/interfaces/IAudioManager.hx" interface="1">
		<isMute public="1" set="_set_isMute">
			<e path="Bool"/>
			<haxe_doc>
	 * If true all audio playback is silenced.
	 </haxe_doc>
		</isMute>
		<start public="1" set="method">
			<f a="id:?audioChannelType:?loops:?startTime:?volume:?pan:?isIgnoredIfPlaying:?onCompleteCallback">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Begin playback of any specified sound.  Optional parameters allow further control.
	 * @param	id	The unique id of the audio media asset.  Can be the className of a loaded asset library.
	 * @param	?audioChannelType	Sounds can be assigned specific channels to allow transformation of groups of related sounds.
	 * @param	?loops	How many times the specified sound should repeat.  Set to -1 for continual loop.
	 * @param	?startTime	Time displacement (ms) from the start of the sound file.
	 * @param	?volume	Adjusts this sound's amplitude relative to the audioChannel.  0...1: 0 is silent, 1 is full.
	 * @param	?pan	Adjusts this sound's stereo effect relative to the audioChannel.  -1...1: -1 is left channel only, 0 is central, 1 is right channel only.
	 * @param	?isIgnoredIfPlaying	If true and this sound is already playing in the specified channel the start request will be skipped.  If false there is a potential for the same sound to play over the top of itself.
	 * @param	?onCompleteCallback	Callback method to execute on sound complete.
	 </haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a="?id:?audioChannelType">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * End playback of any specified sound.  To stop all sounds on all channels, leave all parameters blank.
	 * @param	?id	The unique id of the audio media asset intended to be stopped.  If null will stop all sounds on the specific audioChannel.
	 * @param	?audioChannelType	If specified will only stop sounds assigned to this channel.
	 </haxe_doc>
		</stop>
		<transform public="1" set="method">
			<f a="?id:?audioChannelType:?volume:?pan:?asRelative">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adjusts the playback of any specified sound.  To adjust all sounds, ommit id and audioChannelType.
	 * @param	?id	The unique id of the audio media asset intended to be transformed.  If null will transform all sounds on the specific audioChannel.
	 * @param	?audioChannelType	If specified will only transform sounds assigned to this channel.
	 * @param	?volume	Adjusts this sound's amplitude relative to the audioChannel.  0...1: 0 is silent, 1 is full.
	 * @param	?pan	Adjusts this sound's stereo effect relative to the audioChannel.  -1...1: -1 is left channel only, 0 is central, 1 is right channel only.
	 * @param	?asRelative	If true will adjust sounds relative to their original transformation.  If false will set them as absolute values.
	 </haxe_doc>
		</transform>
		<isPlaying public="1" set="method">
			<f a="?id:?audioChannelType">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Discover if a specified sound is playing.
	 * @param	?id	The unique id of the audio media asset under investigation.  If null will search entire audioChannel for activity.
	 * @param	?audioChannelType	If specified will only investigate the specified channel.  If ommitted will investigate all channels.
	 * @return	Returns true if a match is found, otherwise false.
	 </haxe_doc>
		</isPlaying>
		<haxe_doc>
 * Provides functions to control playback of audio: sounds, music etc. 
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.AAudioManager" params="" file="src/awe6/core/drivers/AAudioManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IAudioManager"/>
		<_PACKAGE_ID get="inline" set="null" line="44" static="1"><c path="String"/></_PACKAGE_ID>
		<isMute public="1" set="_set_isMute"><e path="Bool"/></isMute>
		<_sounds><c path="Array"><c path="awe6.core.drivers._AHelperSound"/></c></_sounds>
		<_packageId><c path="String"/></_packageId>
		<_init set="method" line="50" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="66" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="78" override="1"><f a=""><e path="Void"/></f></_disposer>
		<start public="1" set="method" line="88"><f a="p_id:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_isIgnoredIfPlaying:?p_onCompleteCallback">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></start>
		<_driverSoundFactory set="method" line="105"><f a="p_id:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_onCompleteCallback">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<f a=""><e path="Void"/></f>
	<c path="awe6.core.drivers._AHelperSound"/>
</f></_driverSoundFactory>
		<stop public="1" set="method" line="111"><f a="?p_id:?p_audioChannelType">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<e path="Void"/>
</f></stop>
		<transform public="1" set="method" line="120"><f a="?p_id:?p_audioChannelType:?p_volume:?p_pan:?p_asRelative">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></transform>
		<_set_isMute set="method" line="129"><f a="?p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isMute>
		<_driverSetIsMute set="method" line="140"><f a="?p_value">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverSetIsMute>
		<_getSounds set="method" line="145"><f a="?p_id:?p_audioChannelType">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Array"><c path="awe6.core.drivers._AHelperSound"/></c>
</f></_getSounds>
		<isPlaying public="1" set="method" line="185"><f a="?p_id:?p_audioChannelType">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<e path="Bool"/>
</f></isPlaying>
		<new public="1" set="method" line="42"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The AudioManager class provides a minimalist implementation of the IAudioManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers._AHelperSound" params="" file="src/awe6/core/drivers/AAudioManager.hx" module="awe6.core.drivers.AAudioManager">
		<implements path="awe6.interfaces.IDisposable"/>
		<isDisposed public="1" set="null"><e path="Bool"/></isDisposed>
		<id public="1"><c path="String"/></id>
		<audioChannelType public="1"><e path="awe6.interfaces.EAudioChannel"/></audioChannelType>
		<_packageId><c path="String"/></_packageId>
		<_loops><c path="Int"/></_loops>
		<_startTime><c path="Int"/></_startTime>
		<_volume><c path="Float"/></_volume>
		<_pan><c path="Float"/></_pan>
		<_onCompleteCallback><f a=""><e path="Void"/></f></_onCompleteCallback>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_init set="method" line="227"><f a=""><e path="Void"/></f></_init>
		<_driverInit set="method" line="232"><f a=""><e path="Void"/></f></_driverInit>
		<transform public="1" set="method" line="237"><f a="?p_volume:?p_pan:?p_asRelative">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></transform>
		<_driverTransform set="method" line="248"><f a="?p_asRelative">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverTransform>
		<stop public="1" set="method" line="253"><f a=""><e path="Void"/></f></stop>
		<_driverStop set="method" line="259"><f a=""><e path="Void"/></f></_driverStop>
		<dispose public="1" set="method" line="264"><f a=""><e path="Void"/></f></dispose>
		<_driverDisposer set="method" line="274"><f a=""><e path="Void"/></f></_driverDisposer>
		<new public="1" set="method" line="208"><f a="p_kernel:p_id:p_packageId:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_onCompleteCallback">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="225" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="253" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="292" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="207"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="221"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.FontStyle" params="" file="C:\Motion-Twin\haxe/std/flash9/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
	</enum>
	<class path="flash.display.Scene" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.ui.Multitouch" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/Multitouch.hx" extern="1">
		<inputMode public="1" static="1"><e path="flash.ui.MultitouchInputMode"/></inputMode>
		<maxTouchPoints public="1" static="1"><c path="Int"/></maxTouchPoints>
		<supportedGestures public="1" static="1"><c path="flash.Vector"><c path="String"/></c></supportedGestures>
		<supportsGestureEvents public="1" static="1"><e path="Bool"/></supportsGestureEvents>
		<supportsTouchEvents public="1" static="1"><e path="Bool"/></supportsTouchEvents>
	</class>
	<typedef path="awe6.core.InputKeyboard" params="" file="src/awe6/core/InputKeyboard.hx">
		<c path="awe6.core.drivers.flash.InputKeyboard"/>
		<haxe_doc><![CDATA[
 * The InputKeyboard class provides a minimalist implementation of the IInputKeyboard interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>InputKeyboard includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="flash.geom.Vector3D" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<length public="1" set="null"><c path="Float"/></length>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<w public="1"><c path="Float"/></w>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<z public="1"><c path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1"><f a="sourceVector3D">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></copyFrom>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<setTo public="1"><f a="xa:ya:za">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="awe6.interfaces.IOverlayProcess" params="" file="src/awe6/interfaces/IOverlayProcess.hx" interface="1">
		<implements path="awe6.interfaces.IViewable"/>
		<implements path="awe6.interfaces.IProcess"/>
		<implements path="awe6.interfaces.IOverlay"/>
		<haxe_doc><![CDATA[
 * The IOverlayProcess interface should be implemented by objects representing an operating IOverlay.
 * <p>These extra interface requirements are required for internal workings, but are not exposed via the minimal IOverlay interface.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AOverlay" params="" file="src/awe6/core/drivers/AOverlay.hx">
		<extends path="awe6.core.Entity"/>
		<implements path="awe6.interfaces.IOverlayProcess"/>
		<pauseEntity public="1" get="_get_pauseEntity" set="_set_pauseEntity"><c path="awe6.interfaces.IEntity"/></pauseEntity>
		<_borderView><c path="awe6.interfaces.IView"/></_borderView>
		<_progressContext><t path="awe6.core.Context"/></_progressContext>
		<_progressView><c path="awe6.interfaces.IView"/></_progressView>
		<_pauseContext><t path="awe6.core.Context"/></_pauseContext>
		<_pauseView><c path="awe6.interfaces.IView"/></_pauseView>
		<_flashContext><t path="awe6.core.Context"/></_flashContext>
		<_flashView><c path="awe6.interfaces.IView"/></_flashView>
		<_context><t path="awe6.core.Context"/></_context>
		<_pauseColor><c path="Int"/></_pauseColor>
		<_pauseAlpha><c path="Float"/></_pauseAlpha>
		<_pauseBlur><c path="Float"/></_pauseBlur>
		<_flashDuration><c path="Float"/></_flashDuration>
		<_flashAlpha><c path="Float"/></_flashAlpha>
		<_flashStartingAlpha><c path="Float"/></_flashStartingAlpha>
		<_flashStartingDuration><c path="Float"/></_flashStartingDuration>
		<_flashAsTime><e path="Bool"/></_flashAsTime>
		<_wasMute><e path="Bool"/></_wasMute>
		<_buttonBack><c path="awe6.core.BasicButton"/></_buttonBack>
		<_buttonMute><c path="awe6.core.BasicButton"/></_buttonMute>
		<_buttonUnmute><c path="awe6.core.BasicButton"/></_buttonUnmute>
		<_buttonPause><c path="awe6.core.BasicButton"/></_buttonPause>
		<_buttonUnpause><c path="awe6.core.BasicButton"/></_buttonUnpause>
		<_init set="method" line="89" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverInit set="method" line="135"><f a=""><e path="Void"/></f></_driverInit>
		<_updater set="method" line="143" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="171" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_getButton set="method" line="181"><f a="p_type">
	<e path="awe6.interfaces.EOverlayButton"/>
	<c path="awe6.core.BasicButton"/>
</f></_getButton>
		<showButton public="1" set="method" line="194"><f a="p_type:?p_isVisible">
	<e path="awe6.interfaces.EOverlayButton"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></showButton>
		<positionButton public="1" set="method" line="207"><f a="p_type:p_x:p_y">
	<e path="awe6.interfaces.EOverlayButton"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></positionButton>
		<showProgress public="1" set="method" line="214"><f a="p_progress:?p_message">
	<c path="Float"/>
	<c path="String"/>
	<e path="Void"/>
</f></showProgress>
		<hideButtons public="1" set="method" line="219"><f a=""><e path="Void"/></f></hideButtons>
		<flash public="1" set="method" line="228"><f a="?p_duration:?p_asTime:?p_startingAlpha:?p_color">
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></flash>
		<activateButton public="1" set="method" line="236"><f a="p_type">
	<e path="awe6.interfaces.EOverlayButton"/>
	<e path="Void"/>
</f></activateButton>
		<_drawPause set="method" line="283"><f a="?p_isVisible">
	<e path="Bool"/>
	<e path="Void"/>
</f></_drawPause>
		<_get_pauseEntity set="method" line="288"><f a=""><c path="awe6.interfaces.IEntity"/></f></_get_pauseEntity>
		<_set_pauseEntity set="method" line="293"><f a="p_value">
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.interfaces.IEntity"/>
</f></_set_pauseEntity>
		<new public="1" set="method" line="74"><f a="p_kernel:?p_border:?p_backUp:?p_backOver:?p_muteUp:?p_muteOver:?p_unmuteUp:?p_unmuteOver:?p_pauseUp:?p_pauseOver:?p_unpauseUp:?p_unpauseOver:?p_pauseBlur:?p_pauseColor:?p_pauseAlpha">
	<c path="awe6.interfaces.IKernel"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The Overlay class provides a minimalist implementation of the IOverlay interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.display.IGraphicsData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/IGraphicsData.hx" extern="1" interface="1"/>
	<class path="flash.media.SoundChannel" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.media.Camera" params="" file="C:\Motion-Twin\haxe/std/flash9/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1"><f a=""><e path="Void"/></f></_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<fps public="1" set="null"><c path="Float"/></fps>
		<height public="1" set="null"><c path="Int"/></height>
		<index public="1" set="null"><c path="Int"/></index>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<quality public="1" set="null"><c path="Int"/></quality>
		<width public="1" set="null"><c path="Int"/></width>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="StringTools" params="" file="C:\Motion-Twin\haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
	</enum>
	<class path="flash.media.SoundMixer" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundMixer.hx" extern="1">
		<audioPlaybackMode public="1" static="1"><c path="String"/></audioPlaybackMode>
		<bufferTime public="1" static="1"><c path="Int"/></bufferTime>
		<soundTransform public="1" static="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useSpeakerphoneForVoice public="1" static="1"><e path="Bool"/></useSpeakerphoneForVoice>
		<areSoundsInaccessible public="1" set="method" static="1"><f a=""><e path="Bool"/></f></areSoundsInaccessible>
		<computeSpectrum public="1" set="method" static="1"><f a="outputArray:?FFTMode:?stretchFactor">
	<c path="flash.utils.ByteArray"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></computeSpectrum>
		<stopAll public="1" set="method" static="1"><f a=""><e path="Void"/></f></stopAll>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
	</enum>
	<enum path="awe6.interfaces.ETextStyle" params="" file="src/awe6/interfaces/ETextStyle.hx">
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows ETextStyle to be extended (e.g. for using project specific text styles).
	 </haxe_doc>
		</SUB_TYPE>
		<SUBHEAD/>
		<SMALLPRINT/>
		<OVERSIZED/>
		<HEADLINE/>
		<BUTTON/>
		<BODY/>
		<haxe_doc><![CDATA[
 * Representing default identifiers of ITextStyles.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<enum path="flash.display.LineScaleMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
	</enum>
	<enum path="flash.display.GradientType" params="" file="C:\Motion-Twin\haxe/std/flash9/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
	</enum>
	<typedef path="awe6.core.Profiler" params="" file="src/awe6/core/Profiler.hx">
		<c path="awe6.core.drivers.flash.Profiler"/>
		<haxe_doc><![CDATA[
 * The Profiler class provides debug information.  Based on net.hires.utils.Stats by Mr.doob & Theo v1.3
 * <p>Profiler includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.ISceneTransition" params="" file="src/awe6/interfaces/ISceneTransition.hx" interface="1">
		<implements path="awe6.interfaces.IViewable"/>
		<implements path="awe6.interfaces.IProgress"/>
		<implements path="awe6.interfaces.IProcess"/>
		<getDuration public="1" set="method">
			<f a="?asTime">
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * The time over which the transition occurs.
	 * @param	?asTime	If true returns duration in milliseconds, else updates.
	 * @return	The time over which the transition occurs.
	 </haxe_doc>
		</getDuration>
		<haxe_doc>
 * The ISceneTransition interface should be implemented by objects intended to display visual transitions during scene changes.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.ASceneTransition" params="" file="src/awe6/core/drivers/ASceneTransition.hx">
		<extends path="awe6.core.Entity"/>
		<implements path="awe6.interfaces.ISceneTransition"/>
		<progress public="1" get="_get_progress" set="null"><c path="Float"/></progress>
		<_duration><c path="Int"/></_duration>
		<_context><t path="awe6.core.Context"/></_context>
		<_init set="method" line="56" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="61" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<getDuration public="1" set="method" line="70"><f a="?p_asTime">
	<e path="Bool"/>
	<c path="Float"/>
</f></getDuration>
		<_get_progress set="method" line="75"><f a=""><c path="Float"/></f></_get_progress>
		<new public="1" set="method" line="49"><f a="p_kernel:?p_duration">
	<c path="awe6.interfaces.IKernel"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The ASceneTransition class provides a minimalist implementation of the ISceneTransition interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<enum path="flash.display.StageQuality" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH/>
		<BEST/>
	</enum>
	<class path="flash.net.Responder" params="" file="C:\Motion-Twin\haxe/std/flash9/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.media.ID3Info" params="" file="C:\Motion-Twin\haxe/std/flash9/media/ID3Info.hx" extern="1">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="haxe.io.Eof" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\Motion-Twin\haxe/std/flash9/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<needsSoftKeyboard public="1"><e path="Bool"/></needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1"><c path="flash.geom.Rectangle"/></softKeyboardInputAreaOfInterest>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<requestSoftKeyboard public="1"><f a=""><e path="Bool"/></f></requestSoftKeyboard>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\haxe/std/flash9/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></removeChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<startTouchDrag public="1"><f a="touchPointID:?lockCenter:?bounds">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<stopTouchDrag public="1"><f a="touchPointID">
	<c path="Int"/>
	<e path="Void"/>
</f></stopTouchDrag>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
	</enum>
	<class path="flash.display.LoaderInfo" params="" file="C:\Motion-Twin\haxe/std/flash9/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<height public="1" set="null"><c path="Int"/></height>
		<isURLInaccessible public="1"><e path="Bool"/></isURLInaccessible>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<uncaughtErrorEvents public="1"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><c path="Int"/></width>
	</class>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
	</enum>
	<class path="haxe.io.Input" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" set="method" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" set="method" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="234"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="249"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="C:\Motion-Twin\haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<readByte public="1" set="method" line="56" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="75" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<setEndian set="method" line="106" override="1"><f a="e">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readFloat public="1" set="method" line="112" override="1"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="116" override="1"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="120" override="1"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="124" override="1"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="128" override="1"><f a=""><c path="Int"/></f></readUInt16>
		<readInt31 public="1" set="method" line="132" override="1"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="139" override="1"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="146" override="1"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="150" override="1"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<new public="1" set="method" line="35"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundLoaderContext" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundLoaderContext.hx" extern="1">
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
	</enum>
	<enum path="flash.geom.Orientation3D" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
	</enum>
	<class path="flash.Lib" params="" file="C:\Motion-Twin\haxe/std/flash9/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
	</enum>
	<class path="awe6.core.InputManager" params="" file="src/awe6/core/InputManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IInputManager"/>
		<joypad public="1" set="null"><c path="awe6.interfaces.IInputJoypad"/></joypad>
		<keyboard public="1" set="null"><c path="awe6.interfaces.IInputKeyboard"/></keyboard>
		<mouse public="1" set="null"><c path="awe6.interfaces.IInputMouse"/></mouse>
		<_inputKeyboard><t path="awe6.core.InputKeyboard"/></_inputKeyboard>
		<_inputMouse><t path="awe6.core.InputMouse"/></_inputMouse>
		<_init set="method" line="53" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="61" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="68" override="1"><f a=""><e path="Void"/></f></_disposer>
		<createJoypad public="1" set="method" line="75"><f a="?p_up:?p_right:?p_down:?p_left:?p_primary:?p_secondary:?p_upAlt:?p_rightAlt:?p_downAlt:?p_leftAlt:?p_primaryAlt:?p_secondaryAlt">
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<c path="awe6.interfaces.IInputJoypad"/>
</f></createJoypad>
		<reset public="1" set="method" line="80"><f a=""><e path="Bool"/></f></reset>
		<new public="1" set="method" line="44"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The InputManager class provides a minimalist implementation of the IInputManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.utils.IDataInput" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.display3D.IndexBuffer3D" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/IndexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
	</enum>
	<class path="flash.display3D.textures.Texture" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.utils.ByteArray" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><t path="UInt"/></length>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<position public="1"><t path="UInt"/></position>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<deflate public="1" set="method"><f a=""><e path="Void"/></f></deflate>
		<inflate public="1" set="method"><f a=""><e path="Void"/></f></inflate>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="awe6.interfaces.IKernel" params="" file="src/awe6/interfaces/IKernel.hx" interface="1">
		<implements path="awe6.interfaces.ILogger"/>
		<implements path="awe6.interfaces.IPauseable"/>
		<isDebug public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Defined by the IFactory, can be used for conditional logic relating to build modes and debug.
	 </haxe_doc>
		</isDebug>
		<isLocal public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Identifies a non network location, can be used for conditional logic relating to build modes and debug.
	 </haxe_doc>
		</isLocal>
		<isEyeCandy public="1" set="_set_isEyeCandy">
			<e path="Bool"/>
			<haxe_doc>
	 * Toggleable by the user, intended to be used as a switch to disable intensive, but non essential, content (performance vs wow).
	 </haxe_doc>
		</isEyeCandy>
		<isFullScreen public="1" set="_set_isFullScreen">
			<e path="Bool"/>
			<haxe_doc>
	 * Toggleable by the user, enables or disables full screen mode.
	 </haxe_doc>
		</isFullScreen>
		<overlay public="1" set="null">
			<c path="awe6.interfaces.IOverlay"/>
			<haxe_doc><![CDATA[
	 * The topmost visual element, used for chrome & global controls.
	 ]]></haxe_doc>
		</overlay>
		<assets public="1" set="null">
			<c path="awe6.interfaces.IAssetManager"/>
			<haxe_doc>
	 * Assets manager.
	 </haxe_doc>
		</assets>
		<audio public="1" set="null">
			<c path="awe6.interfaces.IAudioManager"/>
			<haxe_doc>
	 * Audio manager.
	 </haxe_doc>
		</audio>
		<inputs public="1" set="null">
			<c path="awe6.interfaces.IInputManager"/>
			<haxe_doc>
	 * Inputs manager.
	 </haxe_doc>
		</inputs>
		<scenes public="1" set="null">
			<c path="awe6.interfaces.ISceneManager"/>
			<haxe_doc>
	 * Scene manager.  State machine containing IEntities.
	 </haxe_doc>
		</scenes>
		<messenger public="1" set="null">
			<c path="awe6.interfaces.IMessageManager"/>
			<haxe_doc>
	 * Messenger manager.  Arbitrator for observer pattern across IEntityCollections.
	 </haxe_doc>
		</messenger>
		<tools public="1" set="null">
			<c path="awe6.interfaces.ITools"/>
			<haxe_doc>
	 * Helper methods.
	 </haxe_doc>
		</tools>
		<factory public="1" set="null">
			<c path="awe6.interfaces.IFactory"/>
			<haxe_doc>
	 * Build properties and factory methods to create the application.
	 </haxe_doc>
		</factory>
		<session public="1" get="_get_session" set="_set_session">
			<c path="awe6.interfaces.ISession"/>
			<haxe_doc>
	 * Read and write globally accessible variables.
	 </haxe_doc>
		</session>
		<getConfig public="1" set="method">
			<f a="id">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	 * Used for read only application settings and localisation text.
	 * @param	ID	Unique identifier for the config setting (e.g. XML node name).
	 * @return	Value of the corresponding config setting.
	 </haxe_doc>
		</getConfig>
		<getFramerate public="1" set="method">
			<f a="?asActual">
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Request the framerate of the application.
	 * @param	?asActual	Use actual framerate (potentially laggy), or the desired framerate (from IFactory).
	 * @return	Frames per second.
	 </haxe_doc>
		</getFramerate>
		<onPreloaderComplete public="1" set="method">
			<f a="preloader">
				<c path="awe6.interfaces.IPreloader"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Internal method called when preloader completes; launches the starting scene as defined by IFactory.startingSceneType.
	 * @param	preloader	Corresponding IPreloader.
	 </haxe_doc>
		</onPreloaderComplete>
		<haxe_doc>
 * Handles main updates and provides global locators for all managers
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="flash.net.URLRequest" params="" file="C:\Motion-Twin\haxe/std/flash9/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1"><c path="String"/></digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="List" params="T" file="C:\Motion-Twin\haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="awe6.interfaces.IPositionable" params="" file="src/awe6/interfaces/IPositionable.hx" interface="1">
		<x public="1" set="_set_x">
			<c path="Float"/>
			<haxe_doc>
	 * The horizontal position.
	 </haxe_doc>
		</x>
		<y public="1" set="_set_y">
			<c path="Float"/>
			<haxe_doc>
	 * The vertical position.
	 </haxe_doc>
		</y>
		<setPosition public="1" set="method">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets both the horizontal and vertical position;
	 * @param	x	The horizontal position.
	 * @param	y	The vertical position.
	 </haxe_doc>
		</setPosition>
		<haxe_doc>
 * The IPositionable interface should be implemented by objects intended to have 2D spatial position.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IPriority" params="" file="src/awe6/interfaces/IPriority.hx" interface="1">
		<priority public="1" get="_get_priority" set="_set_priority">
			<c path="Int"/>
			<haxe_doc><![CDATA[
	 * The rank score of this item.
	 * <p>Higher numbers should be considered on top of the list, therefore of higher priority.</p>
	 ]]></haxe_doc>
		</priority>
		<haxe_doc>
 * The IPriority interface should be implemented by objects intended to be ranked or sorted.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.interfaces.IView" params="" file="src/awe6/interfaces/IView.hx" interface="1">
		<implements path="awe6.interfaces.IUpdateable"/>
		<implements path="awe6.interfaces.IDisposable"/>
		<implements path="awe6.interfaces.IPositionable"/>
		<implements path="awe6.interfaces.IPriority"/>
		<owner public="1" set="null">
			<d/>
			<haxe_doc>
	 * Optional: the object who this view represents.
	 </haxe_doc>
		</owner>
		<parent public="1" get="_get_parent" set="null">
			<c path="awe6.interfaces.IView"/>
			<haxe_doc><![CDATA[
	 * The parent view of this view.
	 * <p>The reference is null if this view has no parent (for exemple a view not in the view traversal stack).</p>
	 ]]></haxe_doc>
		</parent>
		<isVisible public="1" set="_set_isVisible">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Specify the visibility of this view.
	 * <p>If true the view will be displayed, if false the view is hidden.</p>
	 ]]></haxe_doc>
		</isVisible>
		<isInViewStack public="1" get="_get_isInViewStack" set="null">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Determined by whether this view is visible and included in a visible branch of the view stack (i.e. actually has the potential to be drawn within the overlay).
	 * <p>If true the view is potentially visible, if false the view is impossible to be seen.</p>
	 ]]></haxe_doc>
		</isInViewStack>
		<globalX public="1" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The horizontal position considering all parent's positions / scene graph.
	 </haxe_doc>
		</globalX>
		<globalY public="1" set="null">
			<c path="Float"/>
			<haxe_doc>
	 * The vertical position considering all parent's positions / scene graph.
	 </haxe_doc>
		</globalY>
		<addChild public="1" set="method">
			<f a="child:?priority">
				<c path="awe6.interfaces.IView"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a new view child to this view. 
	 * <p>A view can have multiple children, and when you add a child to a view, it is automatically connected to the parent node through its parent property.</p>
	 * @param	child	The child view to add.
	 * @param	?priority	The sorting priority of the child view to add.  Higher numbers will appear towards the top of the view stack.  Default value is 0.
	 ]]></haxe_doc>
		</addChild>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="awe6.interfaces.IView"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Remove the specified view.
	 * <p>The removed view will no longer be included in the view traversal stack so will no longer be visible.</p>
	 * <p>The view itself is still in memory, if you want to free them completely call child.dispose().</p>
	 * @param	child	The view to remove.
	 ]]></haxe_doc>
		</removeChild>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Removes all child views.
	 * <p>The children are still in memory, if you want to free them completely call view.dispose() from their owner object.</p>
	 ]]></haxe_doc>
		</clear>
		<remove public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Removes this view from the view traversal stack and subsequently all of its child views.
	 * <p>The view itself is still in memory, if you want to free it completely call dispose().</p>
	 ]]></haxe_doc>
		</remove>
		<haxe_doc>
 * The IView interface should be implemented by all objects in the view broad phase traversal stack.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.AView" params="" file="src/awe6/core/drivers/AView.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IView"/>
		<context public="1" set="null"><t path="awe6.core.Context"/></context>
		<priority public="1" get="_get_priority" set="_set_priority"><c path="Int"/></priority>
		<owner public="1" set="null"><d/></owner>
		<parent public="1" get="_get_parent" set="null"><c path="awe6.interfaces.IView"/></parent>
		<isVisible public="1" set="_set_isVisible"><e path="Bool"/></isVisible>
		<isInViewStack public="1" get="_get_isInViewStack" set="null"><e path="Bool"/></isInViewStack>
		<x public="1" set="_set_x"><c path="Float"/></x>
		<y public="1" set="_set_y"><c path="Float"/></y>
		<globalX public="1" set="null"><c path="Float"/></globalX>
		<globalY public="1" set="null"><c path="Float"/></globalY>
		<_isDirty><e path="Bool"/></_isDirty>
		<_children><c path="Array"><c path="awe6.core.drivers.AView"/></c></_children>
		<_init set="method" line="66" override="1"><f a=""><e path="Void"/></f></_init>
		<addChild public="1" set="method" line="75"><f a="p_child:?p_priority">
	<c path="awe6.interfaces.IView"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" set="method" line="98"><f a="p_child">
	<c path="awe6.interfaces.IView"/>
	<e path="Void"/>
</f></removeChild>
		<remove public="1" set="method" line="117"><f a=""><e path="Void"/></f></remove>
		<clear public="1" set="method" line="125"><f a=""><e path="Void"/></f></clear>
		<_updater set="method" line="133" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="146" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_driverDisposer set="method" line="154"><f a=""><e path="Void"/></f></_driverDisposer>
		<_draw set="method" line="159"><f a=""><e path="Void"/></f></_draw>
		<_driverDraw set="method" line="170"><f a=""><e path="Void"/></f></_driverDraw>
		<_setParent set="method" line="175"><f a="p_parent">
	<c path="awe6.interfaces.IView"/>
	<e path="Void"/>
</f></_setParent>
		<_get_priority set="method" line="180"><f a=""><c path="Int"/></f></_get_priority>
		<_set_priority set="method" line="185"><f a="p_value">
	<c path="Int"/>
	<c path="Int"/>
</f></_set_priority>
		<_set_isVisible set="method" line="203"><f a="p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isVisible>
		<_get_parent set="method" line="221"><f a=""><c path="awe6.interfaces.IView"/></f></_get_parent>
		<_get_isInViewStack set="method" line="226"><f a=""><e path="Bool"/></f></_get_isInViewStack>
		<_set_x set="method" line="243"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_x>
		<_set_y set="method" line="250"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_y>
		<setPosition public="1" set="method" line="257"><f a="p_x:p_y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<new public="1" set="method" line="58"><f a="p_kernel:?p_context:?p_priority:?p_owner">
	<c path="awe6.interfaces.IKernel"/>
	<t path="awe6.core.Context"/>
	<c path="Int"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The View class provides a minimalist implementation of the IView interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.geom.PerspectiveProjection" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<focalLength public="1"><c path="Float"/></focalLength>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.media.Sound" params="" file="C:\Motion-Twin\haxe/std/flash9/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<isURLInaccessible public="1"><e path="Bool"/></isURLInaccessible>
		<length public="1" set="null"><c path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<extract public="1" set="method"><f a="target:length:?startPosition">
	<c path="flash.utils.ByteArray"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></extract>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1"><f a="bytes:bytesLength">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1"><f a="bytes:samples:?format:?stereo:?sampleRate">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Float"/>
	<e path="Void"/>
</f></loadPCMFromByteArray>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display3D.Context3D" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
	</class>
	<class path="flash.xml.XML" params="" file="C:\Motion-Twin\haxe/std/flash9/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1"><f a="k">
	<c path="String"/>
	<d/>
</f></toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="C:\Motion-Twin\haxe/std/flash9/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
	</enum>
	<class path="IntIter" params="" file="C:\Motion-Twin\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<typedef path="awe6.core.AFactory" params="" file="src/awe6/core/AFactory.hx">
		<c path="awe6.core.drivers.flash.Factory"/>
		<haxe_doc><![CDATA[
 * The AFactory class provides a minimalist abstract implementation of the IFactory interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>AFactory includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="flash.geom.Transform" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<matrix3D public="1"><c path="flash.geom.Matrix3D"/></matrix3D>
		<perspectiveProjection public="1"><c path="flash.geom.PerspectiveProjection"/></perspectiveProjection>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<getRelativeMatrix3D public="1" set="method"><f a="relativeTo">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Matrix3D"/>
</f></getRelativeMatrix3D>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.StageDisplayState" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
	</enum>
	<class path="flash.display3D.Program3D" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Program3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
	</class>
	<class path="awe6.interfaces.ISceneManager" params="" file="src/awe6/interfaces/ISceneManager.hx" interface="1">
		<scene public="1" get="_get_scene" set="null">
			<c path="awe6.interfaces.IScene"/>
			<haxe_doc><![CDATA[
	 * The currently active scene.
	 * <p>Use as a runtime property and not as an initialization property.</p>
	 ]]></haxe_doc>
		</scene>
		<setScene public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Sets the current scene to a new scene.
	 * @param	type	The new scene.
	 </haxe_doc>
		</setScene>
		<back public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Sets the current scene to the scene returned by IFactory.getBackSceneType().
	 * <p>The new scene should be representative of retreat.</p> 
	 * @see awe6.interfaces.IFactory.getBackSceneType
	 ]]></haxe_doc>
		</back>
		<next public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Sets the current scene to the scene returned by IFactory.getNextSceneType().
	 * <p>The new scene should be representative of progress.</p> 
	 * @see awe6.interfaces.IFactory.getNextSceneType
	 ]]></haxe_doc>
		</next>
		<restart public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Restarts the current scene.
	 * <p>Equivalent of disposing current scene and then setScene to current scene again.</p>
	 ]]></haxe_doc>
		</restart>
		<haxe_doc><![CDATA[
 * The ISceneManager should be implemented by objects intended to manage the IScene state machine.
 * <p>Only a single scene is active at any given update.  Which scene is configured by this manager.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.system.Security" params="" file="C:\Motion-Twin\haxe/std/flash9/system/Security.hx" extern="1">
		<APPLICATION public="1" static="1"><c path="String"/></APPLICATION>
		<LOCAL_TRUSTED public="1" static="1"><c path="String"/></LOCAL_TRUSTED>
		<LOCAL_WITH_FILE public="1" static="1"><c path="String"/></LOCAL_WITH_FILE>
		<LOCAL_WITH_NETWORK public="1" static="1"><c path="String"/></LOCAL_WITH_NETWORK>
		<REMOTE public="1" static="1"><c path="String"/></REMOTE>
		<disableAVM1Loading public="1" static="1"><e path="Bool"/></disableAVM1Loading>
		<exactSettings public="1" static="1"><e path="Bool"/></exactSettings>
		<pageDomain public="1" static="1"><c path="String"/></pageDomain>
		<sandboxType public="1" set="null" static="1"><c path="String"/></sandboxType>
		<allowDomain public="1" set="method" static="1"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></allowDomain>
		<allowInsecureDomain public="1" set="method" static="1"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></allowInsecureDomain>
		<duplicateSandboxBridgeInputArguments public="1" static="1"><f a="toplevel:args">
	<d/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></duplicateSandboxBridgeInputArguments>
		<duplicateSandboxBridgeOutputArgument public="1" static="1"><f a="toplevel:arg">
	<d/>
	<d/>
	<d/>
</f></duplicateSandboxBridgeOutputArgument>
		<loadPolicyFile public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></loadPolicyFile>
		<showSettings public="1" set="method" static="1"><f a="?panel">
	<e path="flash.system.SecurityPanel"/>
	<e path="Void"/>
</f></showSettings>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\Motion-Twin\haxe/std/flash9/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1"><f a="k">
	<c path="String"/>
	<d/>
</f></toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Microphone" params="" file="C:\Motion-Twin\haxe/std/flash9/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<codec public="1"><e path="flash.media.SoundCodec"/></codec>
		<enableVAD public="1"><e path="Bool"/></enableVAD>
		<encodeQuality public="1"><c path="Int"/></encodeQuality>
		<enhancedOptions public="1"><c path="flash.media.MicrophoneEnhancedOptions"/></enhancedOptions>
		<framesPerPacket public="1"><c path="Int"/></framesPerPacket>
		<gain public="1"><c path="Float"/></gain>
		<index public="1" set="null"><c path="Int"/></index>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<noiseSuppressionLevel public="1"><c path="Int"/></noiseSuppressionLevel>
		<rate public="1"><c path="Int"/></rate>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<color public="1"><t path="UInt"/></color>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<redOffset public="1"><c path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.interfaces.IInputKeyboard" params="" file="src/awe6/interfaces/IInputKeyboard.hx" interface="1">
		<getIsKeyDown public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine if a specific key is currently down.
	 * @param	type	They key.
	 * @return	Returns true is the key is currently down, false otherwise.
	 </haxe_doc>
		</getIsKeyDown>
		<getIsKeyPress public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine if a specific key was pressed in the current update frame.
	 * <p>A press is defined as a new down - i.e. was up previous frame, and is down this frame.</p>
	 * @param	type	The key.
	 * @return	Returns true is the key was pressed in the current update, false otherwise.
	 ]]></haxe_doc>
		</getIsKeyPress>
		<getIsKeyRelease public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Determine if a specific key was released in the current update.
	 * <p>A release is defined as a new up - i.e. was down previous frame, and is up this frame.</p>
	 * @param	type	The key.
	 * @return	Returns true is the key was released in the current update, false otherwise.
	 ]]></haxe_doc>
		</getIsKeyRelease>
		<getKeyDownDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EKey"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Determine how long a specific key has been down.
	 * @param	type	The key.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration down (the time held prior to the most recent release).
	 * @return	Returns the duration the key has been down.
	 </haxe_doc>
		</getKeyDownDuration>
		<getKeyUpDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EKey"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Determine how long a specific key has been up.
	 * @param	type	The key.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration up (the time unused prior to the most recent press).
	 * @return	Returns the duration the key has been up.
	 </haxe_doc>
		</getKeyUpDuration>
		<getKeyCode public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Translate a specific key to a keyboard keyCode.
	 * @param	type	The key.
	 * @return	Returns the keyboard keyCode of the corresponding key.
	 </haxe_doc>
		</getKeyCode>
		<getKey public="1" set="method">
			<f a="keyCode">
				<c path="Int"/>
				<e path="awe6.interfaces.EKey"/>
			</f>
			<haxe_doc>
	 * Translate a keyCode to a specific key.
	 * @param	type	The keyCode.
	 * @return	Returns the key of the corresponding keyboard keyCode.
	 </haxe_doc>
		</getKey>
		<haxe_doc>
 * The IInputKeyboard interface should be implemented by an object wishing to be used as a virtual keyboard input device.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.AInputKeyboard" params="" file="src/awe6/core/drivers/AInputKeyboard.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IInputKeyboard"/>
		<_keys><c path="Array"><c path="awe6.core.drivers._AInputKeyboard._HelperKey"/></c></_keys>
		<_buffer><c path="Array"><c path="awe6.core.drivers._AInputKeyboard._HelperKeyEvent"/></c></_buffer>
		<_init set="method" line="47" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverInit set="method" line="54"><f a=""><e path="Void"/></f></_driverInit>
		<_updater set="method" line="59" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="97" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_addEvent set="method" line="103"><f a="p_keyCodeValue:p_isDown">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></_addEvent>
		<_onDown set="method" line="108"><f a="p_keyCode">
	<c path="Int"/>
	<e path="Void"/>
</f></_onDown>
		<_onUp set="method" line="119"><f a="p_keyCode">
	<c path="Int"/>
	<e path="Void"/>
</f></_onUp>
		<_reset set="method" line="129"><f a="?p_event">
	<d/>
	<e path="Void"/>
</f></_reset>
		<getIsKeyDown public="1" set="method" line="139"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<e path="Bool"/>
</f></getIsKeyDown>
		<getIsKeyPress public="1" set="method" line="149"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<e path="Bool"/>
</f></getIsKeyPress>
		<getIsKeyRelease public="1" set="method" line="159"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<e path="Bool"/>
</f></getIsKeyRelease>
		<getKeyDownDuration public="1" set="method" line="169"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EKey"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></getKeyDownDuration>
		<getKeyUpDuration public="1" set="method" line="183"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EKey"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></getKeyUpDuration>
		<getKeyCode public="1" set="method" line="197"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<c path="Int"/>
</f></getKeyCode>
		<getKey public="1" set="method" line="304"><f a="p_keyCode">
	<c path="Int"/>
	<e path="awe6.interfaces.EKey"/>
</f></getKey>
		<new public="1" set="method" line="42"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The InputKeyboard class provides a minimalist implementation of the IInputKeyboard interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers._AInputKeyboard._HelperKey" params="" file="src/awe6/core/drivers/AInputKeyboard.hx" private="1" module="awe6.core.drivers.AInputKeyboard">
		<isUsed public="1"><e path="Bool"/></isUsed>
		<isDown public="1"><e path="Bool"/></isDown>
		<updatesDown public="1"><c path="Int"/></updatesDown>
		<updatesUp public="1"><c path="Int"/></updatesUp>
		<timeDown public="1"><c path="Int"/></timeDown>
		<timeUp public="1"><c path="Int"/></timeUp>
		<updatesDownPrevious public="1"><c path="Int"/></updatesDownPrevious>
		<updatesUpPrevious public="1"><c path="Int"/></updatesUpPrevious>
		<timeDownPrevious public="1"><c path="Int"/></timeDownPrevious>
		<timeUpPrevious public="1"><c path="Int"/></timeUpPrevious>
		<new public="1" set="method" line="333"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.core.drivers._AInputKeyboard._HelperKeyEvent" params="" file="src/awe6/core/drivers/AInputKeyboard.hx" private="1" module="awe6.core.drivers.AInputKeyboard">
		<keyCode public="1"><c path="Int"/></keyCode>
		<isDown public="1"><e path="Bool"/></isDown>
		<new public="1" set="method" line="352"><f a="p_keyCode:p_isDown">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.StageScaleMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
	</enum>
	<class path="awe6.core.BasicButton" params="" file="src/awe6/core/BasicButton.hx">
		<extends path="awe6.core.Entity"/>
		<implements path="awe6.interfaces.IPositionable"/>
		<x public="1" set="_set_x"><c path="Float"/></x>
		<y public="1" set="_set_y"><c path="Float"/></y>
		<width public="1" set="_set_width"><c path="Float"/></width>
		<height public="1" set="_set_height"><c path="Float"/></height>
		<isOver public="1" set="null"><e path="Bool"/></isOver>
		<onClickCallback public="1"><f a=""><e path="Void"/></f></onClickCallback>
		<onRollOverCallback public="1"><f a=""><e path="Void"/></f></onRollOverCallback>
		<onRollOutCallback public="1"><f a=""><e path="Void"/></f></onRollOutCallback>
		<_stateUp><c path="awe6.core._BasicButton._HelperState"/></_stateUp>
		<_stateOver><c path="awe6.core._BasicButton._HelperState"/></_stateOver>
		<_keyType><e path="awe6.interfaces.EKey"/></_keyType>
		<_init set="method" line="69" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="80" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_isPointInsideRectangle set="method" line="106"><f a="p_pointX:p_pointY:p_rectX:p_rectY:p_rectWidth:p_rectHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></_isPointInsideRectangle>
		<onClick public="1" set="method" line="127"><f a=""><e path="Void"/></f></onClick>
		<onRollOver public="1" set="method" line="136"><f a=""><e path="Void"/></f></onRollOver>
		<onRollOut public="1" set="method" line="146"><f a=""><e path="Void"/></f></onRollOut>
		<setPosition public="1" set="method" line="156"><f a="p_x:p_y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<_set_x set="method" line="162"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_x>
		<_set_y set="method" line="172"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_y>
		<_set_width set="method" line="182"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_width>
		<_set_height set="method" line="188"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_height>
		<new public="1" set="method" line="54"><f a="p_kernel:p_up:p_over:?p_width:?p_height:?p_x:?p_y:?p_keyType:?p_onClickCallback:?p_onRollOverCallback:?p_onRollOutCallback">
	<c path="awe6.interfaces.IKernel"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="awe6.interfaces.EKey"/>
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.core._BasicButton._HelperState" params="" file="src/awe6/core/BasicButton.hx" private="1" module="awe6.core.BasicButton">
		<extends path="awe6.core.Entity"/>
		<new public="1" set="method" line="197"><f a="p_kernel:p_view">
	<c path="awe6.interfaces.IKernel"/>
	<c path="awe6.interfaces.IView"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="awe6.core._BasicButton._HelperEState" params="" file="src/awe6/core/BasicButton.hx" private="1" module="awe6.core.BasicButton">
		<UP/>
		<OVER/>
	</enum>
	<class path="awe6.core.drivers.AKernel" params="" file="src/awe6/core/drivers/AKernel.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IKernel"/>
		<_POWERED_BY get="inline" set="null" line="66" static="1"><c path="String"/></_POWERED_BY>
		<_POWERED_BY_URL get="inline" set="null" line="67" static="1"><c path="String"/></_POWERED_BY_URL>
		<_RELEASE_CAUTION get="inline" set="null" line="68" static="1"><c path="String"/></_RELEASE_CAUTION>
		<_RESET_SESSIONS get="inline" set="null" line="69" static="1"><c path="String"/></_RESET_SESSIONS>
		<_EYE_CANDY_ENABLE get="inline" set="null" line="70" static="1"><c path="String"/></_EYE_CANDY_ENABLE>
		<_EYE_CANDY_DISABLE get="inline" set="null" line="71" static="1"><c path="String"/></_EYE_CANDY_DISABLE>
		<_FULL_SCREEN_ENABLE get="inline" set="null" line="72" static="1"><c path="String"/></_FULL_SCREEN_ENABLE>
		<_FULL_SCREEN_DISABLE get="inline" set="null" line="73" static="1"><c path="String"/></_FULL_SCREEN_DISABLE>
		<overlay public="1" set="null"><c path="awe6.interfaces.IOverlay"/></overlay>
		<factory public="1" set="null"><c path="awe6.interfaces.IFactory"/></factory>
		<isDebug public="1" set="null"><e path="Bool"/></isDebug>
		<isLocal public="1" set="null"><e path="Bool"/></isLocal>
		<isEyeCandy public="1" set="_set_isEyeCandy"><e path="Bool"/></isEyeCandy>
		<isFullScreen public="1" set="_set_isFullScreen"><e path="Bool"/></isFullScreen>
		<tools public="1" set="null"><c path="awe6.interfaces.ITools"/></tools>
		<assets public="1" set="null"><c path="awe6.interfaces.IAssetManager"/></assets>
		<audio public="1" set="null"><c path="awe6.interfaces.IAudioManager"/></audio>
		<inputs public="1" set="null"><c path="awe6.interfaces.IInputManager"/></inputs>
		<scenes public="1" set="null"><c path="awe6.interfaces.ISceneManager"/></scenes>
		<messenger public="1" set="null"><c path="awe6.interfaces.IMessageManager"/></messenger>
		<session public="1" get="_get_session" set="_set_session"><c path="awe6.interfaces.ISession"/></session>
		<_context><t path="awe6.core.Context"/></_context>
		<_view><t path="awe6.core.View"/></_view>
		<_assetManagerProcess><c path="awe6.interfaces.IAssetManagerProcess"/></_assetManagerProcess>
		<_audioManager><t path="awe6.core.AudioManager"/></_audioManager>
		<_inputManager><c path="awe6.core.InputManager"/></_inputManager>
		<_sceneManager><c path="awe6.core.SceneManager"/></_sceneManager>
		<_messageManager><c path="awe6.core.MessageManager"/></_messageManager>
		<_overlayProcess><c path="awe6.interfaces.IOverlayProcess"/></_overlayProcess>
		<_logger><c path="awe6.interfaces.ILogger"/></_logger>
		<_isPreloaded><e path="Bool"/></_isPreloaded>
		<_preloader><c path="awe6.interfaces.IPreloader"/></_preloader>
		<_profiler><t path="awe6.core.Profiler"/></_profiler>
		<_processes><c path="List"><c path="awe6.interfaces.IProcess"/></c></_processes>
		<_helperFramerate><c path="awe6.core.drivers._AKernel._HelperFramerate"/></_helperFramerate>
		<_init set="method" line="112" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverGetIsLocal set="method" line="161"><f a=""><e path="Bool"/></f></_driverGetIsLocal>
		<_driverInit set="method" line="167"><f a=""><e path="Void"/></f></_driverInit>
		<_driverDisposer set="method" line="172"><f a=""><e path="Void"/></f></_driverDisposer>
		<onPreloaderComplete public="1" set="method" line="177"><f a="p_preloader">
	<c path="awe6.interfaces.IPreloader"/>
	<e path="Void"/>
</f></onPreloaderComplete>
		<_updater set="method" line="202" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="213" override="1"><f a=""><e path="Void"/></f></_disposer>
		<getConfig public="1" set="method" line="240"><f a="p_id">
	<c path="String"/>
	<d/>
</f></getConfig>
		<log public="1" set="method" line="245"><f a="p_value">
	<d/>
	<e path="Void"/>
</f></log>
		<getFramerate public="1" set="method" line="257"><f a="?p_asActual">
	<e path="Bool"/>
	<c path="Float"/>
</f></getFramerate>
		<_addProcess set="method" line="262"><f a="p_process:?p_isLast">
	<c path="awe6.interfaces.IProcess"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></_addProcess>
		<_removeProcess set="method" line="278"><f a="p_process">
	<c path="awe6.interfaces.IProcess"/>
	<e path="Bool"/>
</f></_removeProcess>
		<_totalReset set="method" line="288"><f a=""><e path="Void"/></f></_totalReset>
		<_set_isEyeCandy set="method" line="299"><f a="p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isEyeCandy>
		<_driverSetIsEyeCandy set="method" line="311"><f a="p_value">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverSetIsEyeCandy>
		<_set_isFullScreen set="method" line="316"><f a="p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isFullScreen>
		<_driverSetIsFullScreen set="method" line="328"><f a="p_value">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverSetIsFullScreen>
		<_pauser set="method" line="333" override="1"><f a=""><e path="Void"/></f></_pauser>
		<_resumer set="method" line="342" override="1"><f a=""><e path="Void"/></f></_resumer>
		<_get_session set="method" line="351"><f a=""><c path="awe6.interfaces.ISession"/></f></_get_session>
		<_set_session set="method" line="356"><f a="p_value">
	<c path="awe6.interfaces.ISession"/>
	<c path="awe6.interfaces.ISession"/>
</f></_set_session>
		<new public="1" set="method" line="104"><f a="p_factory:p_context">
	<c path="awe6.interfaces.IFactory"/>
	<t path="awe6.core.Context"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The AKernel class provides a minimalist implementation of the IKernel interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 * @author	Mihail Ivanchev
 ]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers._AKernel._HelperFramerate" params="" file="src/awe6/core/drivers/AKernel.hx" private="1" module="awe6.core.drivers.AKernel">
		<framerate public="1" set="null"><c path="Float"/></framerate>
		<timeInterval public="1" set="null"><c path="Int"/></timeInterval>
		<_timeAtLastUpdate><c path="Int"/></_timeAtLastUpdate>
		<update public="1" set="method" line="375"><f a=""><e path="Void"/></f></update>
		<_timer get="inline" set="null" line="382"><f a=""><c path="Int"/></f></_timer>
		<new public="1" set="method" line="369"><f a="p_framerate">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="XmlType" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" set="method" line="50" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="74" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="78" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="83" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="87" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="92" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="96" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="101" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<getNodeType set="method" line="105" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
</f></getNodeType>
		<wrap set="method" line="181" static="1"><f a="map:node:?type">
	<c path="flash.utils.Dictionary"/>
	<c path="flash.xml.XML"/>
	<e path="XmlType"/>
	<c path="Xml"/>
</f></wrap>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<_map><c path="flash.utils.Dictionary"/></_map>
		<_node><c path="flash.xml.XML"/></_node>
		<getNodeName set="method" line="121"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="128"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="141"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="150"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="177"><f a=""><c path="Xml"/></f></getParent>
		<wraps set="method" line="195"><f a="xList">
	<c path="flash.xml.XMLList"/>
	<c path="Array"><c path="Xml"/></c>
</f></wraps>
		<getAttribNS set="method" line="202"><f a="cur:ns">
	<c path="flash.xml.XML"/>
	<c path="Array"><c path="String"/></c>
	<c path="flash.xml.XMLList"/>
</f></getAttribNS>
		<get public="1" set="method" line="215">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method" line="232">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method" line="253">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method" line="263">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="274">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="290">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="306">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="322">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="347">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="356">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="365">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="372">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="383">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<new set="method" line="72"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>
	The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.
</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<enum path="awe6.interfaces.EAgenda" params="" file="src/awe6/interfaces/EAgenda.hx">
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EAgenda to be extended (e.g. for using entity specific enumerated agendas).
	 </haxe_doc>
		</SUB_TYPE>
		<STANDARD/>
		<DEFEND/>
		<DEATH/>
		<BIRTH/>
		<ATTACK/>
		<ALWAYS><haxe_doc>
	 * The default EAgenda.  Anything assigned to this will be run each update irrespective of what agenda the parent is assigned. 
	 </haxe_doc></ALWAYS>
		<haxe_doc><![CDATA[
 * Can be used to influence the internal state of an IEntity via IAgendaManager.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<enum path="flash.system.SecurityPanel" params="" file="C:\Motion-Twin\haxe/std/flash9/system/SecurityPanel.hx">
		<SETTINGS_MANAGER/>
		<PRIVACY/>
		<MICROPHONE/>
		<LOCAL_STORAGE/>
		<DISPLAY/>
		<DEFAULT/>
		<CAMERA/>
	</enum>
	<class path="flash.net.URLLoader" params="" file="C:\Motion-Twin\haxe/std/flash9/net/URLLoader.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1"><t path="UInt"/></bytesTotal>
		<data public="1"><d/></data>
		<dataFormat public="1"><e path="flash.net.URLLoaderDataFormat"/></dataFormat>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<load public="1" set="method"><f a="request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></load>
		<new public="1" set="method"><f a="?request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.ui.MouseCursorData" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/MouseCursorData.hx" extern="1">
		<data public="1"><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></data>
		<frameRate public="1"><c path="Float"/></frameRate>
		<hotSpot public="1"><c path="flash.geom.Point"/></hotSpot>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Bitmap" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="flash.net.NetConnection" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<farID public="1" set="null"><c path="String"/></farID>
		<farNonce public="1" set="null"><c path="String"/></farNonce>
		<maxPeerConnections public="1"><t path="UInt"/></maxPeerConnections>
		<nearID public="1" set="null"><c path="String"/></nearID>
		<nearNonce public="1" set="null"><c path="String"/></nearNonce>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<protocol public="1" set="null"><c path="String"/></protocol>
		<proxyType public="1"><c path="String"/></proxyType>
		<unconnectedPeerStreams public="1" set="null"><c path="Array"><d/></c></unconnectedPeerStreams>
		<uri public="1" set="null"><c path="String"/></uri>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="awe6.core.drivers.flash.InputMouse" params="" file="src/awe6/core/drivers/flash/InputMouse.hx">
		<extends path="awe6.core.drivers.AInputMouse"/>
		<_stage><c path="flash.display.Stage"/></_stage>
		<_mouseClicks><c path="flash.display.Loader"/></_mouseClicks>
		<_driverInit set="method" line="53" override="1"><f a=""><e path="Void"/></f></_driverInit>
		<_disposer set="method" line="69" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_updater set="method" line="78" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_isMiddleDown set="method" line="84" override="1"><f a=""><e path="Bool"/></f></_isMiddleDown>
		<_isRightDown set="method" line="90" override="1"><f a=""><e path="Bool"/></f></_isRightDown>
		<_isWithinBounds set="method" line="96" override="1"><f a=""><e path="Bool"/></f></_isWithinBounds>
		<_getPosition set="method" line="101" override="1"><f a=""><e path="Void"/></f></_getPosition>
		<_onMouseDown set="method" line="109"><f a="p_event">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></_onMouseDown>
		<_onMouseUp set="method" line="118"><f a="p_event">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></_onMouseUp>
		<_onMouseWheel set="method" line="127"><f a="p_event">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></_onMouseWheel>
		<_set_isVisible set="method" line="136" override="1"><f a="p_value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></_set_isVisible>
		<_set_cursorType set="method" line="142" override="1"><f a="p_value">
	<e path="awe6.interfaces.EMouseCursor"/>
	<e path="awe6.interfaces.EMouseCursor"/>
</f></_set_cursorType>
		<new public="1" set="method" line="48"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This InputMouse class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="Array" params="T" file="C:\Motion-Twin\haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="awe6.core.MessageManager" params="" file="src/awe6/core/MessageManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IMessageManager"/>
		<_subscriptions><c path="haxe.FastList_awe6_core__MessageManager__HelperSubscription"/></_subscriptions>
		<_isVerbose><e path="Bool"/></_isVerbose>
		<_init set="method" line="46" override="1"><f a=""><e path="Void"/></f></_init>
		<addSubscriber public="1" params="M:T" set="method" line="53"><f a="p_subscriber:p_message:p_handler:?p_sender:?p_senderClassType:?p_isRemovedAfterFirstSend">
	<c path="awe6.interfaces.IEntity"/>
	<c path="addSubscriber.M"/>
	<f a=":">
		<c path="addSubscriber.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<e path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<c path="Class"><c path="addSubscriber.T"/></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></addSubscriber>
		<getSubscribers public="1" params="M:T" set="method" line="59"><f a="?p_subscriber:?p_message:?p_handler:?p_sender:?p_senderClassType">
	<c path="awe6.interfaces.IEntity"/>
	<c path="getSubscribers.M"/>
	<f a=":">
		<c path="getSubscribers.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<e path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<c path="Class"><c path="getSubscribers.T"/></c>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></getSubscribers>
		<removeSubscribers public="1" params="M:T" set="method" line="70"><f a="?p_subscriber:?p_message:?p_handler:?p_sender:?p_senderClassType">
	<c path="awe6.interfaces.IEntity"/>
	<c path="removeSubscribers.M"/>
	<f a=":">
		<c path="removeSubscribers.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<e path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<c path="Class"><c path="removeSubscribers.T"/></c>
	<e path="Void"/>
</f></removeSubscribers>
		<sendMessage public="1" params="M" set="method" line="83"><f a="p_message:p_sender:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="sendMessage.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></sendMessage>
		<_sendMessage params="M" set="method" line="88"><f a="p_message:p_sender:p_target:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="_sendMessage.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.interfaces.IEntity"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></_sendMessage>
		<_send params="M" set="method" line="123"><f a="p_subscription:p_message:p_sender">
	<c path="awe6.core._MessageManager._HelperSubscription">
		<d/>
		<d/>
	</c>
	<c path="_send.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<e path="Bool"/>
</f></_send>
		<_getSubscriptions params="M:T" set="method" line="133"><f a="?p_subscriber:?p_message:?p_handler:?p_sender:?p_senderClassType">
	<c path="awe6.interfaces.IEntity"/>
	<c path="_getSubscriptions.M"/>
	<f a=":">
		<c path="_getSubscriptions.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<e path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<c path="Class"><c path="_getSubscriptions.T"/></c>
	<c path="haxe.FastList_awe6_core__MessageManager__HelperSubscription"/>
</f></_getSubscriptions>
		<new public="1" set="method" line="41"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The MessageManager class provides a minimalist implementation of the IMessageManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="awe6.core._MessageManager._HelperSubscription" params="M:T" file="src/awe6/core/MessageManager.hx" private="1" module="awe6.core.MessageManager">
		<subscriber public="1" set="null"><c path="awe6.interfaces.IEntity"/></subscriber>
		<message public="1" set="null"><c path="awe6.core._MessageManager._HelperSubscription.M"/></message>
		<messageClass public="1" set="null"><c path="Class"><c path="awe6.core._MessageManager._HelperSubscription.M"/></c></messageClass>
		<handler public="1" set="null"><f a=":">
	<c path="awe6.core._MessageManager._HelperSubscription.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<e path="Bool"/>
</f></handler>
		<sender public="1" set="null"><c path="awe6.interfaces.IEntity"/></sender>
		<senderClassType public="1" set="null"><c path="Class"><c path="awe6.core._MessageManager._HelperSubscription.T"/></c></senderClassType>
		<isRemovedAfterFirstSend public="1" set="null"><e path="Bool"/></isRemovedAfterFirstSend>
		<new public="1" set="method" line="178"><f a="p_subscriber:p_message:p_handler:?p_sender:?p_senderClassType:?p_isRemovedAfterFirstSend">
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.core._MessageManager._HelperSubscription.M"/>
	<f a=":">
		<c path="awe6.core._MessageManager._HelperSubscription.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<e path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<c path="Class"><c path="awe6.core._MessageManager._HelperSubscription.T"/></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.FullScreenEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/FullScreenEvent.hx" extern="1">
		<extends path="flash.events.ActivityEvent"/>
		<FULL_SCREEN public="1" static="1"><c path="String"/></FULL_SCREEN>
		<fullScreen public="1" set="null"><e path="Bool"/></fullScreen>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?fullScreen">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.StageVideo" params="" file="C:\Motion-Twin\haxe/std/flash9/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<depth public="1"><c path="Int"/></depth>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><c path="Float"/></len>
		<offset public="1"><c path="Float"/></offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><c path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.system.IME" params="" file="C:\Motion-Twin\haxe/std/flash9/system/IME.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<conversionMode public="1" static="1"><e path="flash.system.IMEConversionMode"/></conversionMode>
		<enabled public="1" static="1"><e path="Bool"/></enabled>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<compositionAbandoned public="1" static="1"><f a=""><e path="Void"/></f></compositionAbandoned>
		<compositionSelectionChanged public="1" static="1"><f a="start:end">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></compositionSelectionChanged>
		<doConversion public="1" set="method" static="1"><f a=""><e path="Void"/></f></doConversion>
		<setCompositionString public="1" set="method" static="1"><f a="composition">
	<c path="String"/>
	<e path="Void"/>
</f></setCompositionString>
	</class>
	<enum path="awe6.interfaces.EFullScreen" params="" file="src/awe6/interfaces/EFullScreen.hx">
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EScale to be extended (e.g. for using project specific scale modes).
	 </haxe_doc>
		</SUB_TYPE>
		<SCALE_NEAREST_MULTIPLE><haxe_doc>
	 * Scale without distortion, and doubling pixels (2x2, 4x4 etc) to nearest multiple to preserve pixel sizes.
	 </haxe_doc></SCALE_NEAREST_MULTIPLE>
		<SCALE_ASPECT_RATIO_PRESERVE><haxe_doc>
	 * Scale without aspect ratio distortion.  Non linear pixel sizes may occur.
	 </haxe_doc></SCALE_ASPECT_RATIO_PRESERVE>
		<SCALE_ASPECT_RATIO_IGNORE><haxe_doc>
	 * Scale without preserving aspect ratio - some distortion may occur, including non linear pixel sizes.
	 </haxe_doc></SCALE_ASPECT_RATIO_IGNORE>
		<NO_SCALE><haxe_doc>
	 * Preserves original pixel size.
	 </haxe_doc></NO_SCALE>
		<DISABLED><haxe_doc>
	 * FullScreen mode is not available.
	 </haxe_doc></DISABLED>
		<haxe_doc><![CDATA[
 * Representing possible full screen modes.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
	</enum>
	<class path="awe6.core.SceneManager" params="" file="src/awe6/core/SceneManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.ISceneManager"/>
		<scene public="1" get="_get_scene" set="null"><c path="awe6.interfaces.IScene"/></scene>
		<view public="1" set="null"><c path="awe6.interfaces.IView"/></view>
		<_sceneTransition><c path="awe6.interfaces.ISceneTransition"/></_sceneTransition>
		<_init set="method" line="56" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="62" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="75" override="1"><f a=""><e path="Void"/></f></_disposer>
		<setScene public="1" set="method" line="89"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<e path="Void"/>
</f></setScene>
		<back public="1" set="method" line="123"><f a=""><e path="Void"/></f></back>
		<next public="1" set="method" line="128"><f a=""><e path="Void"/></f></next>
		<restart public="1" set="method" line="137"><f a=""><e path="Void"/></f></restart>
		<_get_scene set="method" line="146"><f a=""><c path="awe6.interfaces.IScene"/></f></_get_scene>
		<new public="1" set="method" line="51"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The SceneManager class provides a minimalist implementation of the ISceneManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="haxe.FastCell_awe6_core__Entity__HelperEntityAgendaPair" params="" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx">
		<elt public="1"><c path="awe6.core._Entity._HelperEntityAgendaPair"/></elt>
		<next public="1"><c path="haxe.FastCell_awe6_core__Entity__HelperEntityAgendaPair"/></next>
		<new public="1" set="method" line="30"><f a="elt:next">
	<c path="awe6.core._Entity._HelperEntityAgendaPair"/>
	<c path="haxe.FastCell_awe6_core__Entity__HelperEntityAgendaPair"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextInteractionMode" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
	</enum>
	<class path="flash.display.ShaderData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.MouseEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<altKey public="1"><e path="Bool"/></altKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<delta public="1"><c path="Int"/></delta>
		<isRelatedObjectInaccessible public="1"><e path="Bool"/></isRelatedObjectInaccessible>
		<localX public="1"><c path="Float"/></localX>
		<localY public="1"><c path="Float"/></localY>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamMulticastInfo.hx" extern="1">
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="awe6.core.drivers.flash.Overlay" params="" file="src/awe6/core/drivers/flash/Overlay.hx">
		<extends path="awe6.core.drivers.AOverlay"/>
		<_pauseSnapshot><c path="flash.display.BitmapData"/></_pauseSnapshot>
		<_driverInit set="method" line="47" override="1"><f a=""><e path="Void"/></f></_driverInit>
		<_updater set="method" line="67" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<flash public="1" set="method" line="73" override="1"><f a="?p_duration:?p_asTime:?p_startingAlpha:?p_color">
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></flash>
		<_drawPause set="method" line="84" override="1"><f a="?p_isVisible">
	<e path="Bool"/>
	<e path="Void"/>
</f></_drawPause>
		<new public="1" set="method" line="43"><f a="p_kernel:?p_border:?p_backUp:?p_backOver:?p_muteUp:?p_muteOver:?p_unmuteUp:?p_unmuteOver:?p_pauseUp:?p_pauseOver:?p_unpauseUp:?p_unpauseOver:?p_pauseBlur:?p_pauseColor:?p_pauseAlpha">
	<c path="awe6.interfaces.IKernel"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This Overlay class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="flash.utils.RegExp" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/RegExp.hx" extern="1">
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<global public="1" set="null"><e path="Bool"/></global>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<exec public="1" set="method"><f a="?s">
	<c path="String"/>
	<d/>
</f></exec>
		<test public="1" set="method"><f a="?s">
	<c path="String"/>
	<e path="Bool"/>
</f></test>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.events.EventPhase" params="" file="C:\Motion-Twin\haxe/std/flash9/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="C:\Motion-Twin\haxe/std/flash9/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
	</enum>
	<class path="flash.system.System" params="" file="C:\Motion-Twin\haxe/std/flash9/system/System.hx" extern="1">
		<freeMemory public="1" static="1"><c path="Float"/></freeMemory>
		<ime public="1" set="null" static="1"><c path="flash.system.IME"/></ime>
		<privateMemory public="1" static="1"><c path="Float"/></privateMemory>
		<processCPUUsage public="1" static="1"><c path="Float"/></processCPUUsage>
		<totalMemory public="1" set="null" static="1"><t path="UInt"/></totalMemory>
		<totalMemoryNumber public="1" static="1"><c path="Float"/></totalMemoryNumber>
		<useCodePage public="1" static="1"><e path="Bool"/></useCodePage>
		<vmVersion public="1" set="null" static="1"><c path="String"/></vmVersion>
		<disposeXML public="1" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="Void"/>
</f></disposeXML>
		<exit public="1" set="method" static="1"><f a="code">
	<t path="UInt"/>
	<e path="Void"/>
</f></exit>
		<gc public="1" set="method" static="1"><f a=""><e path="Void"/></f></gc>
		<pause public="1" set="method" static="1"><f a=""><e path="Void"/></f></pause>
		<pauseForGCIfCollectionImminent public="1" static="1"><f a="?imminence">
	<c path="Float"/>
	<e path="Void"/>
</f></pauseForGCIfCollectionImminent>
		<resume public="1" set="method" static="1"><f a=""><e path="Void"/></f></resume>
		<setClipboard public="1" set="method" static="1"><f a="string">
	<c path="String"/>
	<e path="Void"/>
</f></setClipboard>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="flash.geom.Rectangle" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Rectangle.hx" extern="1">
		<bottom public="1"><c path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><c path="Float"/></height>
		<left public="1"><c path="Float"/></left>
		<right public="1"><c path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><c path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<copyFrom public="1"><f a="sourceRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<setTo public="1"><f a="xa:ya:widtha:heighta">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\Motion-Twin\haxe/std/flash9/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<currentFrameLabel public="1" set="null"><c path="String"/></currentFrameLabel>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><e path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<isPlaying public="1"><e path="Bool"/></isPlaying>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="awe6.core.drivers.flash.View" params="" file="src/awe6/core/drivers/flash/View.hx">
		<extends path="awe6.core.drivers.AView"/>
		<_container><t path="awe6.core.Context"/></_container>
		<_init set="method" line="42" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverDisposer set="method" line="51" override="1"><f a=""><e path="Void"/></f></_driverDisposer>
		<_driverDraw set="method" line="59" override="1"><f a=""><e path="Void"/></f></_driverDraw>
		<_set_x set="method" line="78" override="1"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_x>
		<_set_y set="method" line="84" override="1"><f a="p_value">
	<c path="Float"/>
	<c path="Float"/>
</f></_set_y>
		<new public="1" set="method" line="38"><f a="p_kernel:?p_context:?p_priority:?p_owner">
	<c path="awe6.interfaces.IKernel"/>
	<t path="awe6.core.Context"/>
	<c path="Int"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This View class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="flash.display.Shader" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Shader.hx" extern="1">
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.ColorCorrection" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
	</enum>
	<class path="flash.text.TextField" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1"><f a="fontName:fontStyle">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></isFontCompatible>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><e path="Bool"/></background>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<border public="1"><e path="Bool"/></border>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><c path="Int"/></length>
		<maxChars public="1"><c path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><e path="Bool"/></multiline>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><c path="Int"/></scrollH>
		<scrollV public="1"><c path="Int"/></scrollV>
		<selectable public="1"><e path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<sharpness public="1"><c path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><t path="UInt"/></textColor>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textInteractionMode public="1"><e path="flash.text.TextInteractionMode"/></textInteractionMode>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<thickness public="1"><c path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="C:\Motion-Twin\haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="Type" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="86" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="90" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="111" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="128" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="149" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="162" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="174" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="180" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="197" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="201" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="208" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="213" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="245" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="262" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="266" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="270" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="274" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>
		Returns the list of all enum values that don't take any parameter.
	</haxe_doc>
		</allEnums>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="C:\Motion-Twin\haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="flash.utils.ByteArray"/></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="flash.utils.ByteArray"/></f></initCodes>
		<run public="1" set="method" line="356" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a single value and return it.
	</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><c path="Int"/></pos>
		<length><c path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><d/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="160"><f a=""><d/></f></unserialize>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><c path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<width public="1" set="null"><c path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><t path="UInt"/></c>
</f></getVector>
		<histogram public="1" set="method"><f a="?hRect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
</f></histogram>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setVector public="1" set="method"><f a="rect:inputVector">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><t path="UInt"/></c>
	<e path="Void"/>
</f></setVector>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="awe6.core.Overlay" params="" file="src/awe6/core/Overlay.hx">
		<c path="awe6.core.drivers.flash.Overlay"/>
		<haxe_doc><![CDATA[
 * The Overlay class provides a minimalist implementation of the IOverlay interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>Overlay includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<enum path="flash.display.PixelSnapping" params="" file="C:\Motion-Twin\haxe/std/flash9/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="C:\Motion-Twin\haxe/std/flash9/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
	</enum>
	<class path="flash.media.SoundTransform" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<pan public="1"><c path="Float"/></pan>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<volume public="1"><c path="Float"/></volume>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Point" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><c path="Float"/></length>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1"><f a="sourcePoint">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<setTo public="1"><f a="xa:ya">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTo>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Loader" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<uncaughtErrorEvents public="1"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<unloadAndStop public="1" set="method"><f a="?gc">
	<e path="Bool"/>
	<e path="Void"/>
</f></unloadAndStop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.text.TextLineMetrics" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><c path="Float"/></ascent>
		<descent public="1"><c path="Float"/></descent>
		<height public="1"><c path="Float"/></height>
		<leading public="1"><c path="Float"/></leading>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="awe6.interfaces.EMouseButton" params="" file="src/awe6/interfaces/EMouseButton.hx">
		<RIGHT/>
		<MIDDLE/>
		<LEFT/>
		<haxe_doc>
 * Representing the buttons on a Mouse for use in the IInputMouse virtual controller.
 * @author	Robert Fell
 </haxe_doc>
	</enum>
	<class path="awe6.core.drivers.flash.Session" params="" file="src/awe6/core/drivers/flash/Session.hx">
		<extends path="awe6.core.drivers.ASession"/>
		<_so><c path="flash.net.SharedObject"/></_so>
		<_driverLoad set="method" line="42" override="1"><f a=""><e path="Void"/></f></_driverLoad>
		<_driverReset set="method" line="48" override="1"><f a=""><e path="Void"/></f></_driverReset>
		<_driverSave set="method" line="54" override="1"><f a=""><e path="Void"/></f></_driverSave>
		<new public="1" set="method" line="38"><f a="p_kernel:?p_id">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This Session class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
	</enum>
	<class path="awe6.core.drivers.flash.SceneTransition" params="" file="src/awe6/core/drivers/flash/SceneTransition.hx">
		<extends path="awe6.core.drivers.ASceneTransition"/>
		<_blurFilter><c path="flash.filters.BlurFilter"/></_blurFilter>
		<_init set="method" line="44" override="1"><f a=""><e path="Void"/></f></_init>
		<_updater set="method" line="60" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<new public="1" set="method" line="40"><f a="p_kernel:?p_duration">
	<c path="awe6.interfaces.IKernel"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This SceneTransition class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="52" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<class path="flash.net.SharedObject" params="" file="C:\Motion-Twin\haxe/std/flash9/net/SharedObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<deleteAll public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></deleteAll>
		<getDiskUsage public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></getDiskUsage>
		<getLocal public="1" set="method" static="1"><f a="name:?localPath:?secure">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getLocal>
		<getRemote public="1" set="method" static="1"><f a="name:?remotePath:?persistence:?secure">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getRemote>
		<client public="1"><d/></client>
		<data public="1" set="null"><d/></data>
		<fps public="1" get="null"><c path="Float"/></fps>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<size public="1" set="null"><t path="UInt"/></size>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<connect public="1" set="method"><f a="myConnection:?params">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></connect>
		<flush public="1" set="method"><f a="?minDiskSpace">
	<c path="Int"/>
	<c path="String"/>
</f></flush>
		<send public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<setDirty public="1" set="method"><f a="propertyName">
	<c path="String"/>
	<e path="Void"/>
</f></setDirty>
		<setProperty public="1" set="method"><f a="propertyName:?value">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setProperty>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="awe6.core.Encrypter" params="" file="src/awe6/core/Encrypter.hx">
		<implements path="awe6.interfaces.IEncrypter"/>
		<_defaultSecret><c path="String"/></_defaultSecret>
		<encrypt public="1" set="method" line="49"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></encrypt>
		<decrypt public="1" set="method" line="55"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></decrypt>
		<_xor set="method" line="66">
			<f a="p_value:p_secret">
				<t path="haxe.io.BytesData"/>
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc><![CDATA[
	 * XOR favours size over strength.  It is also two-directional for easy testing.
	 * <p>XOR is the default encryption routine used in awe6 because (due to the ease of client side application decompiling) the obfuscation routine is secondary to the secret key concealment.</p>
	 * <p>Tip: haXe offers some interesting approaches towards concealing the key from plainsite.</p>
	 ]]></haxe_doc>
		</_xor>
		<new public="1" set="method" line="44"><f a="p_defaultSecret">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The Encrypter class provides a minimalist implementation of the IEncrypter interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
	</enum>
	<class path="awe6.core.drivers.flash.Kernel" params="" file="src/awe6/core/drivers/flash/Kernel.hx">
		<extends path="awe6.core.drivers.AKernel"/>
		<_stage><c path="flash.display.Stage"/></_stage>
		<_contextMenu><c path="flash.ui.ContextMenu"/></_contextMenu>
		<_eyeCandyEnableContextMenuItem><c path="flash.ui.ContextMenuItem"/></_eyeCandyEnableContextMenuItem>
		<_eyeCandyDisableContextMenuItem><c path="flash.ui.ContextMenuItem"/></_eyeCandyDisableContextMenuItem>
		<_fullScreenEnableContextMenuItem><c path="flash.ui.ContextMenuItem"/></_fullScreenEnableContextMenuItem>
		<_fullScreenDisableContextMenuItem><c path="flash.ui.ContextMenuItem"/></_fullScreenDisableContextMenuItem>
		<_driverGetIsLocal set="method" line="63" override="1"><f a=""><e path="Bool"/></f></_driverGetIsLocal>
		<_driverInit set="method" line="68" override="1"><f a=""><e path="Void"/></f></_driverInit>
		<_driverDisposer set="method" line="133" override="1"><f a=""><e path="Void"/></f></_driverDisposer>
		<_onFullScreen set="method" line="139"><f a="?p_event">
	<c path="flash.events.FullScreenEvent"/>
	<e path="Void"/>
</f></_onFullScreen>
		<_onEnterFrame set="method" line="144"><f a="p_event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></_onEnterFrame>
		<_driverSetIsEyeCandy set="method" line="149" override="1"><f a="p_value">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverSetIsEyeCandy>
		<_driverSetIsFullScreen set="method" line="156" override="1"><f a="p_value">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverSetIsFullScreen>
		<_getFlashVersion set="method" line="198"><f a=""><c path="Float"/></f></_getFlashVersion>
		<new public="1" set="method" line="54"><f a="p_factory:p_context">
	<c path="awe6.interfaces.IFactory"/>
	<t path="awe6.core.Context"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This Kernel class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="haxe.Serializer" params="" file="C:\Motion-Twin\haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>
		If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.
	</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>
		Use constructor indexes for enums instead of names.
		This is less reliable but more compact.
	</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="416" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize a single value and return the string.
	</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<scount><c path="Int"/></scount>
		<useCache public="1"><e path="Bool"/></useCache>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeClassFields set="method" line="136"><f a="v:c">
	<a><hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty></a>
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></serializeClassFields>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeException public="1" set="method" line="397"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Stage" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<allowsFullScreen public="1"><e path="Bool"/></allowsFullScreen>
		<color public="1"><t path="UInt"/></color>
		<colorCorrection public="1"><e path="flash.display.ColorCorrection"/></colorCorrection>
		<colorCorrectionSupport public="1" set="null"><e path="flash.display.ColorCorrectionSupport"/></colorCorrectionSupport>
		<displayContextInfo public="1"><c path="String"/></displayContextInfo>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><c path="Float"/></frameRate>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<softKeyboardRect public="1"><c path="flash.geom.Rectangle"/></softKeyboardRect>
		<stage3Ds public="1"><c path="flash.Vector"><c path="flash.display.Stage3D"/></c></stage3Ds>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageVideos public="1"><c path="flash.Vector"><c path="flash.media.StageVideo"/></c></stageVideos>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<wmodeGPU public="1"><e path="Bool"/></wmodeGPU>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
	</class>
	<class path="flash.system.Capabilities" params="" file="C:\Motion-Twin\haxe/std/flash9/system/Capabilities.hx" extern="1">
		<_internal public="1" set="null" static="1"><t path="UInt"/></_internal>
		<avHardwareDisable public="1" set="null" static="1"><e path="Bool"/></avHardwareDisable>
		<cpuArchitecture public="1" static="1"><c path="String"/></cpuArchitecture>
		<hasAccessibility public="1" set="null" static="1"><e path="Bool"/></hasAccessibility>
		<hasAudio public="1" set="null" static="1"><e path="Bool"/></hasAudio>
		<hasAudioEncoder public="1" set="null" static="1"><e path="Bool"/></hasAudioEncoder>
		<hasEmbeddedVideo public="1" set="null" static="1"><e path="Bool"/></hasEmbeddedVideo>
		<hasIME public="1" set="null" static="1"><e path="Bool"/></hasIME>
		<hasMP3 public="1" set="null" static="1"><e path="Bool"/></hasMP3>
		<hasPrinting public="1" set="null" static="1"><e path="Bool"/></hasPrinting>
		<hasScreenBroadcast public="1" set="null" static="1"><e path="Bool"/></hasScreenBroadcast>
		<hasScreenPlayback public="1" set="null" static="1"><e path="Bool"/></hasScreenPlayback>
		<hasStreamingAudio public="1" set="null" static="1"><e path="Bool"/></hasStreamingAudio>
		<hasStreamingVideo public="1" set="null" static="1"><e path="Bool"/></hasStreamingVideo>
		<hasTLS public="1" set="null" static="1"><e path="Bool"/></hasTLS>
		<hasVideoEncoder public="1" set="null" static="1"><e path="Bool"/></hasVideoEncoder>
		<isDebugger public="1" set="null" static="1"><e path="Bool"/></isDebugger>
		<isEmbeddedInAcrobat public="1" set="null" static="1"><e path="Bool"/></isEmbeddedInAcrobat>
		<language public="1" set="null" static="1"><c path="String"/></language>
		<localFileReadDisable public="1" set="null" static="1"><e path="Bool"/></localFileReadDisable>
		<manufacturer public="1" set="null" static="1"><c path="String"/></manufacturer>
		<maxLevelIDC public="1" set="null" static="1"><c path="String"/></maxLevelIDC>
		<os public="1" set="null" static="1"><c path="String"/></os>
		<pixelAspectRatio public="1" set="null" static="1"><c path="Float"/></pixelAspectRatio>
		<playerType public="1" set="null" static="1"><c path="String"/></playerType>
		<screenColor public="1" set="null" static="1"><c path="String"/></screenColor>
		<screenDPI public="1" set="null" static="1"><c path="Float"/></screenDPI>
		<screenResolutionX public="1" set="null" static="1"><c path="Float"/></screenResolutionX>
		<screenResolutionY public="1" set="null" static="1"><c path="Float"/></screenResolutionY>
		<serverString public="1" set="null" static="1"><c path="String"/></serverString>
		<supports32BitProcesses public="1" static="1"><e path="Bool"/></supports32BitProcesses>
		<supports64BitProcesses public="1" static="1"><e path="Bool"/></supports64BitProcesses>
		<touchscreenType public="1" static="1"><e path="flash.system.TouchscreenType"/></touchscreenType>
		<version public="1" set="null" static="1"><c path="String"/></version>
		<hasMultiChannelAudio public="1" static="1"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasMultiChannelAudio>
	</class>
	<class path="awe6.core.drivers.flash.AudioManager" params="" file="src/awe6/core/drivers/flash/AudioManager.hx">
		<extends path="awe6.core.drivers.AAudioManager"/>
		<_extension><c path="String"/></_extension>
		<_init set="method" line="48" override="1"><f a=""><e path="Void"/></f></_init>
		<_driverSoundFactory set="method" line="55" override="1"><f a="p_id:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_onCompleteCallback">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<f a=""><e path="Void"/></f>
	<c path="awe6.core.drivers._AHelperSound"/>
</f></_driverSoundFactory>
		<_driverSetIsMute set="method" line="60" override="1"><f a="?p_value">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverSetIsMute>
		<new public="1" set="method" line="44"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This AudioManager class provides js target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
	<class path="awe6.core.drivers.flash._HelperSound" params="" file="src/awe6/core/drivers/flash/AudioManager.hx" module="awe6.core.drivers.flash.AudioManager">
		<extends path="awe6.core.drivers._AHelperSound"/>
		<_extension><c path="String"/></_extension>
		<_sound><c path="flash.media.Sound"/></_sound>
		<_soundChannel><c path="flash.media.SoundChannel"/></_soundChannel>
		<_driverInit set="method" line="80" override="1"><f a=""><e path="Void"/></f></_driverInit>
		<_driverTransform set="method" line="97" override="1"><f a="?p_asRelative">
	<e path="Bool"/>
	<e path="Void"/>
</f></_driverTransform>
		<_driverStop set="method" line="112" override="1"><f a=""><e path="Void"/></f></_driverStop>
		<_onSoundComplete set="method" line="121"><f a="p_event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></_onSoundComplete>
		<_driverDisposer set="method" line="130" override="1"><f a=""><e path="Void"/></f></_driverDisposer>
		<new public="1" set="method" line="73"><f a="p_kernel:p_id:p_packageId:p_extension:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_onCompleteCallback">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Date" params="" file="C:\Motion-Twin\haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="awe6.core.AAssetManager" params="" file="src/awe6/core/AAssetManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IAssetManagerProcess"/>
		<_PACKAGE_ID><c path="String"/></_PACKAGE_ID>
		<_init set="method" line="43" override="1"><f a=""><e path="Void"/></f></_init>
		<getAsset public="1" set="method" line="49"><f a="p_id:?p_packageId:?p_args">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></getAsset>
		<new public="1" set="method" line="39"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * The AAssetManager class provides a minimalist implementation of the IAssetManager interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</class>
	<class path="flash.utils.Dictionary" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
	</enum>
	<class path="flash.net.NetStreamInfo" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamInfo.hx" extern="1">
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<uri public="1" set="null"><c path="String"/></uri>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoLossRate public="1"><c path="Float"/></videoLossRate>
		<xmpData public="1" set="null"><d/></xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" get="inline" set="null" line="40" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="44" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="57" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="61" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="67" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="71" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="86" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="92" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="99" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="flash.Vector" params="T" file="C:\Motion-Twin\haxe/std/flash9/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<length public="1"><t path="UInt"/></length>
		<fixed public="1"><e path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Vector class is very similar to Array but is only supported by the Flash Player 10+
</haxe_doc>
	</class>
	<typedef path="awe6.core.InputMouse" params="" file="src/awe6/core/InputMouse.hx">
		<c path="awe6.core.drivers.flash.InputMouse"/>
		<haxe_doc><![CDATA[
 * The InputMouse class provides a minimalist implementation of the IInputMouse interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>InputMouse includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<typedef path="awe6.AAssetManager" params="" file="src/awe6/Types.hx" module="awe6.Types">
		<c path="awe6.core.AAssetManager"/>
		<haxe_doc>
 * This collection is intended to provide:
 * Single dependency for importing all of awe6
 * Single dependency for generating documentaion of awe6
 * Alternative shorthand namespace for awe6 - e.g. no need to reference core or interface packages.
 </haxe_doc>
	</typedef>
	<typedef path="awe6.AFactory" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.AFactory"/></typedef>
	<typedef path="awe6.APreloader" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.APreloader"/></typedef>
	<typedef path="awe6.ASession" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.ASession"/></typedef>
	<typedef path="awe6.AudioManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.AudioManager"/></typedef>
	<typedef path="awe6.BasicButton" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.BasicButton"/></typedef>
	<typedef path="awe6.Context" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Context"/></typedef>
	<typedef path="awe6.Encrypter" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Encrypter"/></typedef>
	<typedef path="awe6.Entity" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Entity"/></typedef>
	<typedef path="awe6.InputJoypad" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.InputJoypad"/></typedef>
	<typedef path="awe6.InputKeyboard" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.InputKeyboard"/></typedef>
	<typedef path="awe6.InputManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.InputManager"/></typedef>
	<typedef path="awe6.InputMouse" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.InputMouse"/></typedef>
	<typedef path="awe6.Kernel" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Kernel"/></typedef>
	<typedef path="awe6.MessageManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.MessageManager"/></typedef>
	<typedef path="awe6.Overlay" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Overlay"/></typedef>
	<typedef path="awe6.Process" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Process"/></typedef>
	<typedef path="awe6.Profiler" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Profiler"/></typedef>
	<typedef path="awe6.Scene" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Scene"/></typedef>
	<typedef path="awe6.SceneManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.SceneManager"/></typedef>
	<typedef path="awe6.SceneTransition" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.SceneTransition"/></typedef>
	<typedef path="awe6.TextStyle" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.TextStyle"/></typedef>
	<typedef path="awe6.Tools" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Tools"/></typedef>
	<typedef path="awe6.View" params="" file="src/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.View"/></typedef>
	<typedef path="awe6.EAgenda" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EAgenda"/></typedef>
	<typedef path="awe6.EAudioChannel" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EAudioChannel"/></typedef>
	<typedef path="awe6.EJoypadButton" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EJoypadButton"/></typedef>
	<typedef path="awe6.EKey" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EKey"/></typedef>
	<typedef path="awe6.EMessage" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EMessage"/></typedef>
	<typedef path="awe6.EMouseButton" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EMouseButton"/></typedef>
	<typedef path="awe6.EMouseCursor" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EMouseCursor"/></typedef>
	<typedef path="awe6.EOverlayButton" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EOverlayButton"/></typedef>
	<typedef path="awe6.EScene" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EScene"/></typedef>
	<typedef path="awe6.ETextAlign" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.ETextAlign"/></typedef>
	<typedef path="awe6.ETextStyle" params="" file="src/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.ETextStyle"/></typedef>
	<typedef path="awe6.IAgendaManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAgendaManager"/></typedef>
	<typedef path="awe6.IAssetManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAssetManager"/></typedef>
	<typedef path="awe6.IAssetManagerProcess" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAssetManagerProcess"/></typedef>
	<typedef path="awe6.IAudioManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAudioManager"/></typedef>
	<typedef path="awe6.IDisposable" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IDisposable"/></typedef>
	<typedef path="awe6.IEncrypter" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IEncrypter"/></typedef>
	<typedef path="awe6.IEntity" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IEntity"/></typedef>
	<typedef path="awe6.IEntityCollection" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IEntityCollection"/></typedef>
	<typedef path="awe6.IFactory" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IFactory"/></typedef>
	<typedef path="awe6.IInputJoypad" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputJoypad"/></typedef>
	<typedef path="awe6.IInputKeyboard" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputKeyboard"/></typedef>
	<typedef path="awe6.IInputManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputManager"/></typedef>
	<typedef path="awe6.IInputMouse" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputMouse"/></typedef>
	<typedef path="awe6.IKernel" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IKernel"/></typedef>
	<typedef path="awe6.ILogger" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ILogger"/></typedef>
	<typedef path="awe6.IMessageManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IMessageManager"/></typedef>
	<typedef path="awe6.IOverlay" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IOverlay"/></typedef>
	<typedef path="awe6.IOverlayProcess" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IOverlayProcess"/></typedef>
	<typedef path="awe6.IPauseable" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPauseable"/></typedef>
	<typedef path="awe6.IPositionable" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPositionable"/></typedef>
	<typedef path="awe6.IPreloader" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPreloader"/></typedef>
	<typedef path="awe6.IPriority" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPriority"/></typedef>
	<typedef path="awe6.IProcess" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IProcess"/></typedef>
	<typedef path="awe6.IProgress" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IProgress"/></typedef>
	<typedef path="awe6.IResettable" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IResettable"/></typedef>
	<typedef path="awe6.IScene" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IScene"/></typedef>
	<typedef path="awe6.ISceneManager" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ISceneManager"/></typedef>
	<typedef path="awe6.ISceneTransition" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ISceneTransition"/></typedef>
	<typedef path="awe6.ISession" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ISession"/></typedef>
	<typedef path="awe6.ITextStyle" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ITextStyle"/></typedef>
	<typedef path="awe6.ITools" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ITools"/></typedef>
	<typedef path="awe6.IUpdateable" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IUpdateable"/></typedef>
	<typedef path="awe6.IView" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IView"/></typedef>
	<typedef path="awe6.IViewable" params="" file="src/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IViewable"/></typedef>
	<class path="awe6.Types" params="" file="src/awe6/Types.hx">
		<new set="method" line="115"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * Adding a class here improves some editors' shortcut keys.  It has no other purpose, hence being private.
 </haxe_doc>
	</class>
	<typedef path="awe6.core.SceneTransition" params="" file="src/awe6/core/SceneTransition.hx">
		<c path="awe6.core.drivers.flash.SceneTransition"/>
		<haxe_doc><![CDATA[
 * The SceneTransition class provides a minimalist implementation of the ISceneTransition interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>APreloader includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="flash.display.Stage3D" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<transparent public="1"><e path="Bool"/></transparent>
		<visible public="1"><e path="Bool"/></visible>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
	</class>
	<enum path="awe6.interfaces.EJoypadButton" params="" file="src/awe6/interfaces/EJoypadButton.hx">
		<UP/>
		<SECONDARY/>
		<RIGHT/>
		<PRIMARY/>
		<LEFT/>
		<FIRE/>
		<DOWN/>
		<haxe_doc><![CDATA[
 * Representing the buttons on a Joypad for use in the IJoypad virtual controller.
 * <p>Includes directional buttons and two fire buttons: Primary & Secondary. Fire is used as a shortcut for Primary or Secondary.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\Motion-Twin\haxe/std/flash9/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><e path="Bool"/></silent>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="String" params="" file="C:\Motion-Twin\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="flash.Boot" params="" file="C:\Motion-Twin\haxe/std/flash9/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="53" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="84" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="93" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="103" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="111" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="115" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="134" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="149" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="191" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<start set="method" line="55"><f a=""><e path="Void"/></f></start>
		<doInitDelay set="method" line="75"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<init set="method" line="80"><f a=""><e path="Void"/></f></init>
		<new public="1" set="method" line="47"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="C:\Motion-Twin\haxe/std/flash9/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxe.FastCell_awe6_core__MessageManager__HelperSubscription" params="" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx">
		<elt public="1"><c path="awe6.core._MessageManager._HelperSubscription">
	<d/>
	<d/>
</c></elt>
		<next public="1"><c path="haxe.FastCell_awe6_core__MessageManager__HelperSubscription"/></next>
		<new public="1" set="method" line="30"><f a="elt:next">
	<c path="awe6.core._MessageManager._HelperSubscription">
		<d/>
		<d/>
	</c>
	<c path="haxe.FastCell_awe6_core__MessageManager__HelperSubscription"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<loop public="1"><e path="Bool"/></loop>
		<play public="1"><e path="Bool"/></play>
		<print public="1"><e path="Bool"/></print>
		<quality public="1"><e path="Bool"/></quality>
		<rewind public="1"><e path="Bool"/></rewind>
		<save public="1"><e path="Bool"/></save>
		<zoom public="1"><e path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.net.URLLoaderDataFormat" params="" file="C:\Motion-Twin\haxe/std/flash9/net/URLLoaderDataFormat.hx">
		<VARIABLES/>
		<TEXT/>
		<BINARY/>
	</enum>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\Motion-Twin\haxe/std/flash9/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Motion-Twin\haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="flash.utils.ByteArray"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
	</enum>
	<enum path="flash.text.FontType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
	</enum>
	<class path="haxe.FastCell" params="T" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx" module="haxe.FastList">
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<new public="1" set="method" line="30"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<add public="1" get="inline" set="null" line="60">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" get="inline" set="null" line="68">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" get="inline" set="null" line="90">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" set="method" line="98">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="123">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="141">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="54">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. A different class is created for each container used in platforms where it matters
</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="awe6.core._Entity._HelperEntityAgendaPair" params="" file="src/awe6/core/Entity.hx" private="1" module="awe6.core.Entity">
		<entity public="1" set="null"><c path="awe6.interfaces.IEntity"/></entity>
		<agenda public="1" set="null"><e path="awe6.interfaces.EAgenda"/></agenda>
		<isAddedToView public="1"><e path="Bool"/></isAddedToView>
		<new public="1" set="method" line="328"><f a="p_entity:?p_agenda">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1"><c path="Float"/></bytesLoaded>
		<bytesTotal public="1"><c path="Float"/></bytesTotal>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="C:\Motion-Twin\haxe/std/flash9/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
	</enum>
	<typedef path="awe6.core.Kernel" params="" file="src/awe6/core/Kernel.hx">
		<c path="awe6.core.drivers.flash.Kernel"/>
		<haxe_doc><![CDATA[
 * The Kernel class provides a minimalist implementation of the IKernel interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>Kernel includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell
 ]]></haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="C:\Motion-Twin\haxe/std/haxe/Timer.hx">
		<delay public="1" set="method" line="77" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<measure public="1" params="T" set="method" line="88" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="98" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<stop public="1" set="method" line="52"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="74"><f a=""><e path="Void"/></f></run>
		<new public="1" set="method" line="37"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="awe6.interfaces.EAudioChannel" params="" file="src/awe6/interfaces/EAudioChannel.hx">
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EAudioChannel to be extended (e.g. for using project specific enumerated audio channels or entity specific channels).
	 </haxe_doc>
		</SUB_TYPE>
		<MUSIC/>
		<INTERFACE/>
		<EFFECTS/>
		<DEFAULT/>
		<haxe_doc><![CDATA[
 * Can be used to separate audio space to allow different transforms to apply to different groups of playing sounds.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell
 ]]></haxe_doc>
	</enum>
	<enum path="flash.ui.KeyLocation" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
	</enum>
	<enum path="flash.text.AntiAliasType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="C:\Motion-Twin\haxe/std/flash9/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1"><e path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><e path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<imageDecodingPolicy public="1"><e path="flash.system.ImageDecodingPolicy"/></imageDecodingPolicy>
		<parameters public="1"><d/></parameters>
		<requestedContentParent public="1"><c path="flash.display.DisplayObjectContainer"/></requestedContentParent>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="awe6.interfaces.EOverlayButton" params="" file="src/awe6/interfaces/EOverlayButton.hx">
		<UNPAUSE/>
		<UNMUTE/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>
	 * Allows EOverlayButton to be extended (e.g. for using project specific overlay buttons - settings, restart, context help).
	 </haxe_doc>
		</SUB_TYPE>
		<PAUSE/>
		<MUTE/>
		<BACK/>
		<haxe_doc>
 * Representing the control buttons on the IOverlay.
 * @author	Robert Fell
 </haxe_doc>
	</enum>
	<enum path="awe6.interfaces.EMouseCursor" params="" file="src/awe6/interfaces/EMouseCursor.hx">
		<SUB_TYPE a="value"><d/></SUB_TYPE>
		<IBEAM/>
		<HAND/>
		<BUTTON/>
		<ARROW/>
		<haxe_doc>
 * Representing the mouse cursor for use in the IInputMouse virtual controller.
 * @author	Robert Fell
 </haxe_doc>
	</enum>
	<class path="awe6.core.drivers.flash.InputKeyboard" params="" file="src/awe6/core/drivers/flash/InputKeyboard.hx">
		<extends path="awe6.core.drivers.AInputKeyboard"/>
		<_stage><c path="flash.display.Stage"/></_stage>
		<_driverInit set="method" line="45" override="1"><f a=""><e path="Void"/></f></_driverInit>
		<_updater set="method" line="53" override="1"><f a="?p_deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></_updater>
		<_disposer set="method" line="59" override="1"><f a=""><e path="Void"/></f></_disposer>
		<_onKeyDown set="method" line="67"><f a="p_event">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></_onKeyDown>
		<_onKeyUp set="method" line="77"><f a="p_event">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></_onKeyUp>
		<new public="1" set="method" line="41"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This InputKeyboard class provides flash target overrides.
 * @author	Robert Fell
 </haxe_doc>
	</class>
</haxe>